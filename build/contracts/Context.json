{
  "contractName": "Context",
  "abi": [],
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"project:/contracts/verify/DodoStrategy.sol\":\"Context\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"project:/contracts/verify/DodoStrategy.sol\":{\"keccak256\":\"0x9e1226c32a25fcb64fe1b03c46bbf83b817c849509ee6cbc8914e0b5a4c02b46\",\"license\":\"Unlicense\",\"urls\":[\"bzz-raw://df044ef6975b099b1ce6fced9c1eb72be60c2b6260b0007c6635fa0cf0272bdc\",\"dweb:/ipfs/QmdjBYLDn7DVXviR8bJBSFJfnL63wJD7kUCgFB4AK8JYYU\"]}},\"version\":1}",
  "bytecode": "0x",
  "deployedBytecode": "0x",
  "immutableReferences": {},
  "generatedSources": [],
  "deployedGeneratedSources": [],
  "sourceMap": "",
  "deployedSourceMap": "",
  "source": "// //SPDX-License-Identifier: Unlicense\r\n// pragma solidity ^0.8.0;\r\n\r\n\r\n// /**\r\n//  * @dev Provides information about the current execution context, including the\r\n//  * sender of the transaction and its data. While these are generally available\r\n//  * via msg.sender and msg.data, they should not be accessed in such a direct\r\n//  * manner, since when dealing with meta-transactions the account sending and\r\n//  * paying for execution may not be the actual sender (as far as an application\r\n//  * is concerned).\r\n//  *\r\n//  * This contract is only required for intermediate, library-like contracts.\r\n//  */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// /**\r\n//  * @dev Contract module which provides a basic access control mechanism, where\r\n//  * there is an account (an owner) that can be granted exclusive access to\r\n//  * specific functions.\r\n//  *\r\n//  * By default, the owner account will be the one that deploys the contract. This\r\n//  * can later be changed with {transferOwnership}.\r\n//  *\r\n//  * This module is used through inheritance. It will make available the modifier\r\n//  * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n//  * the owner.\r\n//  */\r\n// abstract contract Ownable is Context {\r\n//     address private _owner;\r\n\r\n//     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n//     /**\r\n//      * @dev Initializes the contract setting the deployer as the initial owner.\r\n//      */\r\n//     constructor() {\r\n//         _transferOwnership(_msgSender());\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Throws if called by any account other than the owner.\r\n//      */\r\n//     modifier onlyOwner() {\r\n//         _checkOwner();\r\n//         _;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the address of the current owner.\r\n//      */\r\n//     function owner() public view virtual returns (address) {\r\n//         return _owner;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Throws if the sender is not the owner.\r\n//      */\r\n//     function _checkOwner() internal view virtual {\r\n//         require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Leaves the contract without owner. It will not be possible to call\r\n//      * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n//      *\r\n//      * NOTE: Renouncing ownership will leave the contract without an owner,\r\n//      * thereby removing any functionality that is only available to the owner.\r\n//      */\r\n//     function renounceOwnership() public virtual onlyOwner {\r\n//         _transferOwnership(address(0));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n//      * Can only be called by the current owner.\r\n//      */\r\n//     function transferOwnership(address newOwner) public virtual onlyOwner {\r\n//         require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n//         _transferOwnership(newOwner);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n//      * Internal function without access restriction.\r\n//      */\r\n//     function _transferOwnership(address newOwner) internal virtual {\r\n//         address oldOwner = _owner;\r\n//         _owner = newOwner;\r\n//         emit OwnershipTransferred(oldOwner, newOwner);\r\n//     }\r\n// }\r\n\r\n// interface IERC20 {\r\n//     event Approval(address indexed owner, address indexed spender, uint value);\r\n//     event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n//     function name() external view returns (string memory);\r\n//     function symbol() external view returns (string memory);\r\n//     function decimals() external view returns (uint8);\r\n//     function totalSupply() external view returns (uint);\r\n//     function balanceOf(address owner) external view returns (uint);\r\n//     function allowance(address owner, address spender) external view returns (uint);\r\n\r\n//     function approve(address spender, uint value) external returns (bool);\r\n//     function transfer(address to, uint value) external returns (bool);\r\n//     function transferFrom(address from, address to, uint value) external returns (bool);\r\n// }\r\n\r\n// interface IUniswapV2Router01 {\r\n//     function factory() external pure returns (address);\r\n//     function WETH() external pure returns (address);\r\n\r\n//     function addLiquidity(\r\n//         address tokenA,\r\n//         address tokenB,\r\n//         uint amountADesired,\r\n//         uint amountBDesired,\r\n//         uint amountAMin,\r\n//         uint amountBMin,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external returns (uint amountA, uint amountB, uint liquidity);\r\n//     function addLiquidityETH(\r\n//         address token,\r\n//         uint amountTokenDesired,\r\n//         uint amountTokenMin,\r\n//         uint amountETHMin,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n//     function removeLiquidity(\r\n//         address tokenA,\r\n//         address tokenB,\r\n//         uint liquidity,\r\n//         uint amountAMin,\r\n//         uint amountBMin,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external returns (uint amountA, uint amountB);\r\n//     function removeLiquidityETH(\r\n//         address token,\r\n//         uint liquidity,\r\n//         uint amountTokenMin,\r\n//         uint amountETHMin,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external returns (uint amountToken, uint amountETH);\r\n//     function removeLiquidityWithPermit(\r\n//         address tokenA,\r\n//         address tokenB,\r\n//         uint liquidity,\r\n//         uint amountAMin,\r\n//         uint amountBMin,\r\n//         address to,\r\n//         uint deadline,\r\n//         bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//     ) external returns (uint amountA, uint amountB);\r\n//     function removeLiquidityETHWithPermit(\r\n//         address token,\r\n//         uint liquidity,\r\n//         uint amountTokenMin,\r\n//         uint amountETHMin,\r\n//         address to,\r\n//         uint deadline,\r\n//         bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//     ) external returns (uint amountToken, uint amountETH);\r\n//     function swapExactTokensForTokens(\r\n//         uint amountIn,\r\n//         uint amountOutMin,\r\n//         address[] calldata path,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external returns (uint[] memory amounts);\r\n//     function swapTokensForExactTokens(\r\n//         uint amountOut,\r\n//         uint amountInMax,\r\n//         address[] calldata path,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external returns (uint[] memory amounts);\r\n//     function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n//         external\r\n//         payable\r\n//         returns (uint[] memory amounts);\r\n//     function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n//         external\r\n//         returns (uint[] memory amounts);\r\n//     function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n//         external\r\n//         returns (uint[] memory amounts);\r\n//     function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n//         external\r\n//         payable\r\n//         returns (uint[] memory amounts);\r\n\r\n//     function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n//     function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n//     function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n//     function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n//     function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n// }\r\n\r\n// interface IUniswapV2Router02 is IUniswapV2Router01 {\r\n//     function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n//         address token,\r\n//         uint liquidity,\r\n//         uint amountTokenMin,\r\n//         uint amountETHMin,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external returns (uint amountETH);\r\n//     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n//         address token,\r\n//         uint liquidity,\r\n//         uint amountTokenMin,\r\n//         uint amountETHMin,\r\n//         address to,\r\n//         uint deadline,\r\n//         bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n//     ) external returns (uint amountETH);\r\n\r\n//     function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n//         uint amountIn,\r\n//         uint amountOutMin,\r\n//         address[] calldata path,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external;\r\n//     function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n//         uint amountOutMin,\r\n//         address[] calldata path,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external payable;\r\n//     function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n//         uint amountIn,\r\n//         uint amountOutMin,\r\n//         address[] calldata path,\r\n//         address to,\r\n//         uint deadline\r\n//     ) external;\r\n// }\r\n\r\n// interface IUniswapV2Factory {\r\n//     event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n//     function feeTo() external view returns (address);\r\n//     function feeToSetter() external view returns (address);\r\n\r\n//     function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n//     function allPairs(uint) external view returns (address pair);\r\n//     function allPairsLength() external view returns (uint);\r\n\r\n//     function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n//     function setFeeTo(address) external;\r\n//     function setFeeToSetter(address) external;\r\n// }\r\n\r\n\r\n// interface IUniswapV2Pair {\r\n//     event Approval(address indexed owner, address indexed spender, uint value);\r\n//     event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n//     function name() external pure returns (string memory);\r\n//     function symbol() external pure returns (string memory);\r\n//     function decimals() external pure returns (uint8);\r\n//     function totalSupply() external view returns (uint);\r\n//     function balanceOf(address owner) external view returns (uint);\r\n//     function allowance(address owner, address spender) external view returns (uint);\r\n\r\n//     function approve(address spender, uint value) external returns (bool);\r\n//     function transfer(address to, uint value) external returns (bool);\r\n//     function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n//     function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n//     function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n//     function nonces(address owner) external view returns (uint);\r\n\r\n//     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n//     event Mint(address indexed sender, uint amount0, uint amount1);\r\n//     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n//     event Swap(\r\n//         address indexed sender,\r\n//         uint amount0In,\r\n//         uint amount1In,\r\n//         uint amount0Out,\r\n//         uint amount1Out,\r\n//         address indexed to\r\n//     );\r\n//     event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n//     function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n//     function factory() external view returns (address);\r\n//     function token0() external view returns (address);\r\n//     function token1() external view returns (address);\r\n//     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n//     function price0CumulativeLast() external view returns (uint);\r\n//     function price1CumulativeLast() external view returns (uint);\r\n//     function kLast() external view returns (uint);\r\n\r\n//     function mint(address to) external returns (uint liquidity);\r\n//     function burn(address to) external returns (uint amount0, uint amount1);\r\n//     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n//     function skim(address to) external;\r\n//     function sync() external;\r\n\r\n//     function initialize(address, address) external;\r\n// }\r\n\r\n\r\n\r\n// interface IDodoStrategy {\r\n//   function BONUS_MULTIPLIER (  ) external view returns ( uint256 );\r\n//   function CLIP (  ) external view returns ( address );\r\n//   function CLIPPerBlock (  ) external view returns ( uint256 );\r\n//   function add ( uint256 _allocPoint, address _lpToken, bool _withUpdate ) external;\r\n//   function deposit ( uint256 _pid, uint256 _amount ) external;\r\n//   function depositedClip (  ) external view returns ( uint256 );\r\n//   function devPercent (  ) external view returns ( uint256 );\r\n//   function devaddr (  ) external view returns ( address );\r\n//   function emergencyWithdraw ( uint256 _pid ) external;\r\n//   function enterStaking ( uint256 _amount ) external;\r\n//   function getMultiplier ( uint256 _from, uint256 _to ) external view returns ( uint256 );\r\n//   function lastBlockDevWithdraw (  ) external view returns ( uint256 );\r\n//   function leaveStaking ( uint256 _amount ) external;\r\n//   function massUpdatePools (  ) external;\r\n//   function migrate ( uint256 _pid ) external;\r\n//   function migrator (  ) external view returns ( address );\r\n//   function owner (  ) external view returns ( address );\r\n//   function pendingCLIP ( uint256 _pid, address _user ) external view returns ( uint256 );\r\n//   function percentDec (  ) external view returns ( uint256 );\r\n//   function poolInfo ( uint256 ) external view returns ( address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accCLIPPerShare );\r\n//   function poolLength (  ) external view returns ( uint256 );\r\n//   function refAddr (  ) external view returns ( address );\r\n//   function refPercent (  ) external view returns ( uint256 );\r\n//   function renounceOwnership (  ) external;\r\n//   function safuPercent (  ) external view returns ( uint256 );\r\n//   function safuaddr (  ) external view returns ( address );\r\n//   function set ( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) external;\r\n//   function setDevAddress ( address _devaddr ) external;\r\n//   function setMigrator ( address _migrator ) external;\r\n//   function setRefAddress ( address _refaddr ) external;\r\n//   function setSafuAddress ( address _safuaddr ) external;\r\n//   function stakingPercent (  ) external view returns ( uint256 );\r\n//   function startBlock (  ) external view returns ( uint256 );\r\n//   function totalAllocPoint (  ) external view returns ( uint256 );\r\n//   function transferOwnership ( address newOwner ) external;\r\n//   function updateClipPerBlock ( uint256 newAmount ) external;\r\n//   function updateMultiplier ( uint256 multiplierNumber ) external;\r\n//   function updatePool ( uint256 _pid ) external;\r\n//   function userInfo ( uint256, address ) external view returns ( uint256 amount, uint256 rewardDebt );\r\n//   function withdraw ( uint256 _pid, uint256 _amount ) external;\r\n//   function withdrawDevAndRefFee (  ) external;\r\n//   function myStakedBalance() external view returns(uint256);\r\n// }\r\n\r\n// library EnumerableSet {\r\n//     // To implement this library for multiple types with as little code\r\n//     // repetition as possible, we write it in terms of a generic Set type with\r\n//     // bytes32 values.\r\n//     // The Set implementation uses private functions, and user-facing\r\n//     // implementations (such as AddressSet) are just wrappers around the\r\n//     // underlying Set.\r\n//     // This means that we can only create new EnumerableSets for types that fit\r\n//     // in bytes32.\r\n\r\n//     struct Set {\r\n//         // Storage of set values\r\n//         bytes32[] _values;\r\n//         // Position of the value in the `values` array, plus 1 because index 0\r\n//         // means a value is not in the set.\r\n//         mapping(bytes32 => uint256) _indexes;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Add a value to a set. O(1).\r\n//      *\r\n//      * Returns true if the value was added to the set, that is if it was not\r\n//      * already present.\r\n//      */\r\n//     function _add(Set storage set, bytes32 value) private returns (bool) {\r\n//         if (!_contains(set, value)) {\r\n//             set._values.push(value);\r\n//             // The value is stored at length-1, but we add 1 to all indexes\r\n//             // and use 0 as a sentinel value\r\n//             set._indexes[value] = set._values.length;\r\n//             return true;\r\n//         } else {\r\n//             return false;\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Removes a value from a set. O(1).\r\n//      *\r\n//      * Returns true if the value was removed from the set, that is if it was\r\n//      * present.\r\n//      */\r\n//     function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n//         // We read and store the value's index to prevent multiple reads from the same storage slot\r\n//         uint256 valueIndex = set._indexes[value];\r\n\r\n//         if (valueIndex != 0) {\r\n//             // Equivalent to contains(set, value)\r\n//             // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n//             // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n//             // This modifies the order of the array, as noted in {at}.\r\n\r\n//             uint256 toDeleteIndex = valueIndex - 1;\r\n//             uint256 lastIndex = set._values.length - 1;\r\n\r\n//             if (lastIndex != toDeleteIndex) {\r\n//                 bytes32 lastValue = set._values[lastIndex];\r\n\r\n//                 // Move the last value to the index where the value to delete is\r\n//                 set._values[toDeleteIndex] = lastValue;\r\n//                 // Update the index for the moved value\r\n//                 set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n//             }\r\n\r\n//             // Delete the slot where the moved value was stored\r\n//             set._values.pop();\r\n\r\n//             // Delete the index for the deleted slot\r\n//             delete set._indexes[value];\r\n\r\n//             return true;\r\n//         } else {\r\n//             return false;\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns true if the value is in the set. O(1).\r\n//      */\r\n//     function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n//         return set._indexes[value] != 0;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of values on the set. O(1).\r\n//      */\r\n//     function _length(Set storage set) private view returns (uint256) {\r\n//         return set._values.length;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the value stored at position `index` in the set. O(1).\r\n//      *\r\n//      * Note that there are no guarantees on the ordering of values inside the\r\n//      * array, and it may change when more values are added or removed.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `index` must be strictly less than {length}.\r\n//      */\r\n//     function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n//         return set._values[index];\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Return the entire set in an array\r\n//      *\r\n//      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n//      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n//      * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n//      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n//      */\r\n//     function _values(Set storage set) private view returns (bytes32[] memory) {\r\n//         return set._values;\r\n//     }\r\n\r\n//     // Bytes32Set\r\n\r\n//     struct Bytes32Set {\r\n//         Set _inner;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Add a value to a set. O(1).\r\n//      *\r\n//      * Returns true if the value was added to the set, that is if it was not\r\n//      * already present.\r\n//      */\r\n//     function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n//         return _add(set._inner, value);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Removes a value from a set. O(1).\r\n//      *\r\n//      * Returns true if the value was removed from the set, that is if it was\r\n//      * present.\r\n//      */\r\n//     function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n//         return _remove(set._inner, value);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns true if the value is in the set. O(1).\r\n//      */\r\n//     function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n//         return _contains(set._inner, value);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of values in the set. O(1).\r\n//      */\r\n//     function length(Bytes32Set storage set) internal view returns (uint256) {\r\n//         return _length(set._inner);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the value stored at position `index` in the set. O(1).\r\n//      *\r\n//      * Note that there are no guarantees on the ordering of values inside the\r\n//      * array, and it may change when more values are added or removed.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `index` must be strictly less than {length}.\r\n//      */\r\n//     function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n//         return _at(set._inner, index);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Return the entire set in an array\r\n//      *\r\n//      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n//      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n//      * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n//      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n//      */\r\n//     function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n//         return _values(set._inner);\r\n//     }\r\n\r\n//     // AddressSet\r\n\r\n//     struct AddressSet {\r\n//         Set _inner;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Add a value to a set. O(1).\r\n//      *\r\n//      * Returns true if the value was added to the set, that is if it was not\r\n//      * already present.\r\n//      */\r\n//     function add(AddressSet storage set, address value) internal returns (bool) {\r\n//         return _add(set._inner, bytes32(uint256(uint160(value))));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Removes a value from a set. O(1).\r\n//      *\r\n//      * Returns true if the value was removed from the set, that is if it was\r\n//      * present.\r\n//      */\r\n//     function remove(AddressSet storage set, address value) internal returns (bool) {\r\n//         return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns true if the value is in the set. O(1).\r\n//      */\r\n//     function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n//         return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of values in the set. O(1).\r\n//      */\r\n//     function length(AddressSet storage set) internal view returns (uint256) {\r\n//         return _length(set._inner);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the value stored at position `index` in the set. O(1).\r\n//      *\r\n//      * Note that there are no guarantees on the ordering of values inside the\r\n//      * array, and it may change when more values are added or removed.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `index` must be strictly less than {length}.\r\n//      */\r\n//     function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n//         return address(uint160(uint256(_at(set._inner, index))));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Return the entire set in an array\r\n//      *\r\n//      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n//      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n//      * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n//      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n//      */\r\n//     function values(AddressSet storage set) internal view returns (address[] memory) {\r\n//         bytes32[] memory store = _values(set._inner);\r\n//         address[] memory result;\r\n\r\n//         /// @solidity memory-safe-assembly\r\n//         assembly {\r\n//             result := store\r\n//         }\r\n\r\n//         return result;\r\n//     }\r\n\r\n//     // UintSet\r\n\r\n//     struct UintSet {\r\n//         Set _inner;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Add a value to a set. O(1).\r\n//      *\r\n//      * Returns true if the value was added to the set, that is if it was not\r\n//      * already present.\r\n//      */\r\n//     function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n//         return _add(set._inner, bytes32(value));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Removes a value from a set. O(1).\r\n//      *\r\n//      * Returns true if the value was removed from the set, that is if it was\r\n//      * present.\r\n//      */\r\n//     function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n//         return _remove(set._inner, bytes32(value));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns true if the value is in the set. O(1).\r\n//      */\r\n//     function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n//         return _contains(set._inner, bytes32(value));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of values on the set. O(1).\r\n//      */\r\n//     function length(UintSet storage set) internal view returns (uint256) {\r\n//         return _length(set._inner);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the value stored at position `index` in the set. O(1).\r\n//      *\r\n//      * Note that there are no guarantees on the ordering of values inside the\r\n//      * array, and it may change when more values are added or removed.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `index` must be strictly less than {length}.\r\n//      */\r\n//     function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n//         return uint256(_at(set._inner, index));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Return the entire set in an array\r\n//      *\r\n//      * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n//      * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n//      * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n//      * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n//      */\r\n//     function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n//         bytes32[] memory store = _values(set._inner);\r\n//         uint256[] memory result;\r\n\r\n//         /// @solidity memory-safe-assembly\r\n//         assembly {\r\n//             result := store\r\n//         }\r\n\r\n//         return result;\r\n//     }\r\n// }\r\n\r\n\r\n// /**\r\n//  * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n//  *\r\n//  * _Available since v4.1._\r\n//  */\r\n// interface IERC20Metadata is IERC20 {\r\n//     /**\r\n//      * @dev Returns the name of the token.\r\n//      */\r\n//     function name() external view returns (string memory);\r\n\r\n//     /**\r\n//      * @dev Returns the symbol of the token.\r\n//      */\r\n//     function symbol() external view returns (string memory);\r\n\r\n//     /**\r\n//      * @dev Returns the decimals places of the token.\r\n//      */\r\n//     function decimals() external view returns (uint8);\r\n// }\r\n\r\n// /**\r\n//  * @dev Implementation of the {IERC20} interface.\r\n//  *\r\n//  * This implementation is agnostic to the way tokens are created. This means\r\n//  * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n//  * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n//  *\r\n//  * TIP: For a detailed writeup see our guide\r\n//  * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n//  * to implement supply mechanisms].\r\n//  *\r\n//  * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n//  * instead returning `false` on failure. This behavior is nonetheless\r\n//  * conventional and does not conflict with the expectations of ERC20\r\n//  * applications.\r\n//  *\r\n//  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n//  * This allows applications to reconstruct the allowance for all accounts just\r\n//  * by listening to said events. Other implementations of the EIP may not emit\r\n//  * these events, as it isn't required by the specification.\r\n//  *\r\n//  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n//  * functions have been added to mitigate the well-known issues around setting\r\n//  * allowances. See {IERC20-approve}.\r\n//  */\r\n// contract ERC20 is Context, IERC20, IERC20Metadata {\r\n//     mapping(address => uint256) private _balances;\r\n\r\n//     mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n//     uint256 private _totalSupply;\r\n\r\n//     string private _name;\r\n//     string private _symbol;\r\n\r\n//     /**\r\n//      * @dev Sets the values for {name} and {symbol}.\r\n//      *\r\n//      * The default value of {decimals} is 18. To select a different value for\r\n//      * {decimals} you should overload it.\r\n//      *\r\n//      * All two of these values are immutable: they can only be set once during\r\n//      * construction.\r\n//      */\r\n//     constructor(string memory name_, string memory symbol_) {\r\n//         _name = name_;\r\n//         _symbol = symbol_;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the name of the token.\r\n//      */\r\n//     function name() public view virtual override returns (string memory) {\r\n//         return _name;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the symbol of the token, usually a shorter version of the\r\n//      * name.\r\n//      */\r\n//     function symbol() public view virtual override returns (string memory) {\r\n//         return _symbol;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the number of decimals used to get its user representation.\r\n//      * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n//      * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n//      *\r\n//      * Tokens usually opt for a value of 18, imitating the relationship between\r\n//      * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n//      * overridden;\r\n//      *\r\n//      * NOTE: This information is only used for _display_ purposes: it in\r\n//      * no way affects any of the arithmetic of the contract, including\r\n//      * {IERC20-balanceOf} and {IERC20-transfer}.\r\n//      */\r\n//     function decimals() public view virtual override returns (uint8) {\r\n//         return 18;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-totalSupply}.\r\n//      */\r\n//     function totalSupply() public view virtual override returns (uint256) {\r\n//         return _totalSupply;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-balanceOf}.\r\n//      */\r\n//     function balanceOf(address account) public view virtual override returns (uint256) {\r\n//         return _balances[account];\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-transfer}.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `to` cannot be the zero address.\r\n//      * - the caller must have a balance of at least `amount`.\r\n//      */\r\n//     function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n//         address owner = _msgSender();\r\n//         _transfer(owner, to, amount);\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-allowance}.\r\n//      */\r\n//     function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n//         return _allowances[owner][spender];\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-approve}.\r\n//      *\r\n//      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n//      * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `spender` cannot be the zero address.\r\n//      */\r\n//     function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n//         address owner = _msgSender();\r\n//         _approve(owner, spender, amount);\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev See {IERC20-transferFrom}.\r\n//      *\r\n//      * Emits an {Approval} event indicating the updated allowance. This is not\r\n//      * required by the EIP. See the note at the beginning of {ERC20}.\r\n//      *\r\n//      * NOTE: Does not update the allowance if the current allowance\r\n//      * is the maximum `uint256`.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `from` and `to` cannot be the zero address.\r\n//      * - `from` must have a balance of at least `amount`.\r\n//      * - the caller must have allowance for ``from``'s tokens of at least\r\n//      * `amount`.\r\n//      */\r\n//     function transferFrom(\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) public virtual override returns (bool) {\r\n//         address spender = _msgSender();\r\n//         _spendAllowance(from, spender, amount);\r\n//         _transfer(from, to, amount);\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n//      *\r\n//      * This is an alternative to {approve} that can be used as a mitigation for\r\n//      * problems described in {IERC20-approve}.\r\n//      *\r\n//      * Emits an {Approval} event indicating the updated allowance.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `spender` cannot be the zero address.\r\n//      */\r\n//     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n//         address owner = _msgSender();\r\n//         _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n//      *\r\n//      * This is an alternative to {approve} that can be used as a mitigation for\r\n//      * problems described in {IERC20-approve}.\r\n//      *\r\n//      * Emits an {Approval} event indicating the updated allowance.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `spender` cannot be the zero address.\r\n//      * - `spender` must have allowance for the caller of at least\r\n//      * `subtractedValue`.\r\n//      */\r\n//     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n//         address owner = _msgSender();\r\n//         uint256 currentAllowance = allowance(owner, spender);\r\n//         require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n//         unchecked {\r\n//             _approve(owner, spender, currentAllowance - subtractedValue);\r\n//         }\r\n\r\n//         return true;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Moves `amount` of tokens from `from` to `to`.\r\n//      *\r\n//      * This internal function is equivalent to {transfer}, and can be used to\r\n//      * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n//      *\r\n//      * Emits a {Transfer} event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `from` cannot be the zero address.\r\n//      * - `to` cannot be the zero address.\r\n//      * - `from` must have a balance of at least `amount`.\r\n//      */\r\n//     function _transfer(\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) internal virtual {\r\n//         require(from != address(0), \"ERC20: transfer from the zero address\");\r\n//         require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n//         _beforeTokenTransfer(from, to, amount);\r\n\r\n//         uint256 fromBalance = _balances[from];\r\n//         require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n//         unchecked {\r\n//             _balances[from] = fromBalance - amount;\r\n//         }\r\n//         _balances[to] += amount;\r\n\r\n//         emit Transfer(from, to, amount);\r\n\r\n//         _afterTokenTransfer(from, to, amount);\r\n//     }\r\n\r\n//     /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n//      * the total supply.\r\n//      *\r\n//      * Emits a {Transfer} event with `from` set to the zero address.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `account` cannot be the zero address.\r\n//      */\r\n//     function _mint(address account, uint256 amount) internal virtual {\r\n//         require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n//         _beforeTokenTransfer(address(0), account, amount);\r\n\r\n//         _totalSupply += amount;\r\n//         _balances[account] += amount;\r\n//         emit Transfer(address(0), account, amount);\r\n\r\n//         _afterTokenTransfer(address(0), account, amount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Destroys `amount` tokens from `account`, reducing the\r\n//      * total supply.\r\n//      *\r\n//      * Emits a {Transfer} event with `to` set to the zero address.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `account` cannot be the zero address.\r\n//      * - `account` must have at least `amount` tokens.\r\n//      */\r\n//     function _burn(address account, uint256 amount) internal virtual {\r\n//         require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n//         _beforeTokenTransfer(account, address(0), amount);\r\n\r\n//         uint256 accountBalance = _balances[account];\r\n//         require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n//         unchecked {\r\n//             _balances[account] = accountBalance - amount;\r\n//         }\r\n//         _totalSupply -= amount;\r\n\r\n//         emit Transfer(account, address(0), amount);\r\n\r\n//         _afterTokenTransfer(account, address(0), amount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n//      *\r\n//      * This internal function is equivalent to `approve`, and can be used to\r\n//      * e.g. set automatic allowances for certain subsystems, etc.\r\n//      *\r\n//      * Emits an {Approval} event.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `owner` cannot be the zero address.\r\n//      * - `spender` cannot be the zero address.\r\n//      */\r\n//     function _approve(\r\n//         address owner,\r\n//         address spender,\r\n//         uint256 amount\r\n//     ) internal virtual {\r\n//         require(owner != address(0), \"ERC20: approve from the zero address\");\r\n//         require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n//         _allowances[owner][spender] = amount;\r\n//         emit Approval(owner, spender, amount);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n//      *\r\n//      * Does not update the allowance amount in case of infinite allowance.\r\n//      * Revert if not enough allowance is available.\r\n//      *\r\n//      * Might emit an {Approval} event.\r\n//      */\r\n//     function _spendAllowance(\r\n//         address owner,\r\n//         address spender,\r\n//         uint256 amount\r\n//     ) internal virtual {\r\n//         uint256 currentAllowance = allowance(owner, spender);\r\n//         if (currentAllowance != type(uint256).max) {\r\n//             require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n//             unchecked {\r\n//                 _approve(owner, spender, currentAllowance - amount);\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Hook that is called before any transfer of tokens. This includes\r\n//      * minting and burning.\r\n//      *\r\n//      * Calling conditions:\r\n//      *\r\n//      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n//      * will be transferred to `to`.\r\n//      * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n//      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n//      * - `from` and `to` are never both zero.\r\n//      *\r\n//      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n//      */\r\n//     function _beforeTokenTransfer(\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) internal virtual {}\r\n\r\n//     /**\r\n//      * @dev Hook that is called after any transfer of tokens. This includes\r\n//      * minting and burning.\r\n//      *\r\n//      * Calling conditions:\r\n//      *\r\n//      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n//      * has been transferred to `to`.\r\n//      * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n//      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n//      * - `from` and `to` are never both zero.\r\n//      *\r\n//      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n//      */\r\n//     function _afterTokenTransfer(\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) internal virtual {}\r\n// }\r\n\r\n\r\n// library EnumerableSetExtension {\r\n//     /// @dev Function will revert if address is not in set.\r\n//     function indexOf(EnumerableSet.AddressSet storage set, address value) internal view returns (uint256 index) {\r\n//         return set._inner._indexes[bytes32(uint256(uint160(value)))] - 1;\r\n//     }\r\n// }\r\n\r\n\r\n// interface IExchangePlugin {\r\n    \r\n//     function swap(\r\n//         uint256 amountA,\r\n//         address tokenA,\r\n//         address tokenB,\r\n//         address to\r\n//     ) external returns (uint256 amountReceivedTokenB);\r\n\r\n//     /// @notice Returns percent taken by DEX on which we swap provided tokens.\r\n//     /// @dev Fee percent has 18 decimals.\r\n//     function getFee(address tokenA, address tokenB)\r\n//         external\r\n//         view\r\n//         returns (uint256 feePercent);\r\n\r\n//     /// @notice Synonym of the uniswapV2's function, estimates amount you receive after swap.\r\n//     function getAmountOut(uint256 amountA, address tokenA, address tokenB)\r\n//         external\r\n//         view\r\n//         returns (uint256 amountOut);\r\n// }\r\n\r\n\r\n// contract Exchange is Ownable {\r\n//     error RoutedSwapFailed();\r\n//     error RouteNotFound();\r\n\r\n//     struct RouteParams {\r\n//         // default exchange to use, could have low slippage but also lower liquidity\r\n//         address defaultRoute;\r\n//         // whenever input amount is over limit, then should use secondRoute\r\n//         uint256 limit;\r\n//         // second exchange, could have higher slippage but also higher liquidity\r\n//         address secondRoute;\r\n//     }\r\n\r\n//     // which plugin to use for swap for this pair\r\n//     // tokenA -> tokenB -> RouteParams\r\n//     mapping(address => mapping(address => RouteParams)) public routes;\r\n\r\n//     uint256 private constant LIMIT_PRECISION = 1e12;\r\n\r\n//     /// @custom:oz-upgrades-unsafe-allow constructor\r\n//     constructor() {\r\n//         // lock implementation\r\n//         // _disableInitializers();\r\n//     }\r\n\r\n//     // function initialize() external initializer {\r\n//     //     __Ownable_init();\r\n//     //     __UUPSUpgradeable_init();\r\n//     // }\r\n\r\n//     // function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n//     /// @notice Choose plugin where pair of tokens should be swapped.\r\n//     function setRoute(\r\n//         address[] calldata tokensA,\r\n//         address[] calldata tokensB,\r\n//         address[] calldata plugin\r\n//     ) external onlyOwner {\r\n//         for (uint256 i = 0; i < tokensA.length; i++) {\r\n//             (address token0, address token1) = sortTokens(tokensA[i], tokensB[i]);\r\n//             routes[token0][token1].defaultRoute = plugin[i];\r\n//         }\r\n//     }\r\n\r\n//     function setRouteEx(\r\n//         address[] calldata tokensA,\r\n//         address[] calldata tokensB,\r\n//         RouteParams[] calldata _routes\r\n//     ) external onlyOwner {\r\n//         for (uint256 i = 0; i < tokensA.length; i++) {\r\n//             (address token0, address token1) = sortTokens(tokensA[i], tokensB[i]);\r\n//             routes[token0][token1] = _routes[i];\r\n//         }\r\n//     }\r\n\r\n//     function getPlugin(\r\n//         uint256 amountA,\r\n//         address tokenA,\r\n//         address tokenB\r\n//     ) public view returns (address plugin) {\r\n//         (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n//         uint256 limit = routes[token0][token1].limit;\r\n//         // decimals: 12 + tokenA.decimals - 12 = tokenA.decimals\r\n//         uint256 limitWithDecimalsOfTokenA = limit * 10**ERC20(tokenA).decimals() / LIMIT_PRECISION;\r\n//         if (limit == 0 || amountA < limitWithDecimalsOfTokenA) plugin = routes[token0][token1].defaultRoute;\r\n//         else plugin = routes[token0][token1].secondRoute;\r\n//         if (plugin == address(0)) revert RouteNotFound();\r\n//         return plugin;\r\n//     }\r\n\r\n//     function getFee(\r\n//         uint256 amountA,\r\n//         address tokenA,\r\n//         address tokenB\r\n//     ) public view returns (uint256 feePercent) {\r\n//         address plugin = getPlugin(amountA, address(tokenA), address(tokenB));\r\n//         return IExchangePlugin(plugin).getFee(tokenA, tokenB);\r\n//     }\r\n\r\n//     function getAmountOut(\r\n//         uint256 amountA,\r\n//         address tokenA,\r\n//         address tokenB\r\n//     ) external view returns (uint256 amountOut) {\r\n//         address plugin = getPlugin(amountA, address(tokenA), address(tokenB));\r\n//         return IExchangePlugin(plugin).getAmountOut(amountA, tokenA, tokenB);\r\n//     }\r\n\r\n//     function swap(\r\n//         uint256 amountA,\r\n//         address tokenA,\r\n//         address tokenB,\r\n//         address to\r\n//     ) public returns (uint256 amountReceived) {\r\n//         address plugin = getPlugin(amountA, address(tokenA), address(tokenB));\r\n//         IERC20(tokenA).transfer(plugin, amountA);\r\n//         amountReceived = IExchangePlugin(plugin).swap(amountA, tokenA, tokenB, to);\r\n//         if (amountReceived == 0) revert RoutedSwapFailed();\r\n//     }\r\n\r\n//     function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n//         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n//     }\r\n// }\r\n\r\n// interface IUsdOracle {\r\n//     /// @notice Get usd value of token `base`.\r\n//     function getTokenUsdPrice(address base)\r\n//         external\r\n//         view\r\n//         returns (uint256 price, uint8 decimals);\r\n// }\r\n\r\n\r\n// /// @notice This contract contains batch related code, serves as part of StrategyRouter.\r\n// /// @notice This contract should be owned by StrategyRouter.\r\n// contract Batch is Ownable {\r\n//     using EnumerableSet for EnumerableSet.AddressSet;\r\n//     using EnumerableSetExtension for EnumerableSet.AddressSet;\r\n\r\n//     /* ERRORS */\r\n\r\n//     error AlreadySupportedToken();\r\n//     error CantRemoveTokenOfActiveStrategy();\r\n//     error UnsupportedToken();\r\n//     error NotReceiptOwner();\r\n//     error CycleClosed();\r\n//     error DepositUnderMinimum();\r\n//     error NotEnoughBalanceInBatch();\r\n//     error CallerIsNotStrategyRouter();\r\n\r\n//     /// @notice Fires when user withdraw from batch.\r\n//     /// @param token Supported token that user requested to receive after withdraw.\r\n//     /// @param amount Amount of `token` received by user.\r\n//     event WithdrawFromBatch(address indexed user, address token, uint256 amount);\r\n//     event SetAddresses(Exchange _exchange, IUsdOracle _oracle, StrategyRouter _router, ReceiptNFT _receiptNft);\r\n\r\n//     uint8 public constant UNIFORM_DECIMALS = 18;\r\n//     // used in rebalance function, UNIFORM_DECIMALS, so 1e17 == 0.1\r\n//     uint256 public constant REBALANCE_SWAP_THRESHOLD = 1e17;\r\n\r\n//     uint256 public minDeposit;\r\n\r\n//     ReceiptNFT public receiptContract;\r\n//     Exchange public exchange;\r\n//     StrategyRouter public router;\r\n//     IUsdOracle public oracle;\r\n\r\n//     EnumerableSet.AddressSet private supportedTokens;\r\n\r\n//     modifier onlyStrategyRouter() {\r\n//         if (msg.sender != address(router)) revert CallerIsNotStrategyRouter();\r\n//         _;\r\n//     }\r\n\r\n//     /// @custom:oz-upgrades-unsafe-allow constructor\r\n//     constructor() {\r\n//         // lock implementation\r\n//         // _disableInitializers();\r\n//     }\r\n\r\n//     // function initialize() external initializer {\r\n//     //     __Ownable_init();\r\n//     //     __UUPSUpgradeable_init();\r\n//     // }\r\n\r\n//     function setAddresses(\r\n//         Exchange _exchange,\r\n//         IUsdOracle _oracle,\r\n//         StrategyRouter _router,\r\n//         ReceiptNFT _receiptNft\r\n//     ) external onlyOwner {\r\n//         exchange = _exchange;\r\n//         oracle = _oracle;\r\n//         router = _router;\r\n//         receiptContract = _receiptNft;\r\n//         emit SetAddresses(_exchange, _oracle, _router, _receiptNft);\r\n//     }\r\n\r\n//     // function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n//     // Universal Functions\r\n\r\n//     function supportsToken(address tokenAddress) public view returns (bool) {\r\n//         return supportedTokens.contains(tokenAddress);\r\n//     }\r\n\r\n//     /// @dev Returns list of supported tokens.\r\n//     function getSupportedTokens() public view returns (address[] memory) {\r\n//         return supportedTokens.values();\r\n//     }\r\n\r\n//     function getBatchValueUsd()\r\n//         public\r\n//         view\r\n//         returns (uint256 totalBalanceUsd, uint256[] memory supportedTokenBalancesUsd)\r\n//     {\r\n//         supportedTokenBalancesUsd = new uint256[](supportedTokens.length());\r\n//         for (uint256 i; i < supportedTokenBalancesUsd.length; i++) {\r\n//             address token = supportedTokens.at(i);\r\n//             uint256 balance = ERC20(token).balanceOf(address(this));\r\n\r\n//             (uint256 price, uint8 priceDecimals) = oracle.getTokenUsdPrice(token);\r\n//             balance = ((balance * price) / 10**priceDecimals);\r\n//             balance = toUniform(balance, token);\r\n//             supportedTokenBalancesUsd[i] = balance;\r\n//             totalBalanceUsd += balance;\r\n//         }\r\n//     }\r\n\r\n//     // User Functions\r\n\r\n//     /// @notice Withdraw tokens from batch while receipts are in batch.\r\n//     /// @notice Receipts are burned.\r\n//     /// @param receiptIds Receipt NFTs ids.\r\n//     /// @dev Only callable by user wallets.\r\n//     function withdraw(\r\n//         address receiptOwner,\r\n//         uint256[] calldata receiptIds,\r\n//         uint256 _currentCycleId\r\n//     ) public onlyStrategyRouter {\r\n//         for (uint256 i = 0; i < receiptIds.length; i++) {\r\n//             uint256 receiptId = receiptIds[i];\r\n//             if (receiptContract.ownerOf(receiptId) != receiptOwner) revert NotReceiptOwner();\r\n\r\n//             ReceiptNFT.ReceiptData memory receipt = receiptContract.getReceipt(receiptId);\r\n\r\n//             // only for receipts in current batch\r\n//             if (receipt.cycleId != _currentCycleId) revert CycleClosed();\r\n\r\n//             uint256 transferAmount = fromUniform(receipt.tokenAmountUniform, receipt.token);\r\n//             ERC20(receipt.token).transfer(receiptOwner, transferAmount);\r\n//             receiptContract.burn(receiptId);\r\n//             emit WithdrawFromBatch(msg.sender, receipt.token, transferAmount);\r\n//         }\r\n//     }\r\n\r\n//     /// @notice converting token USD amount to token amount, i.e $1000 worth of token with price of $0.5 is 2000 tokens\r\n//     function calculateTokenAmountFromUsdAmount(uint256 valueUsd, address token)\r\n//         internal\r\n//         view\r\n//         returns (uint256 tokenAmountToTransfer)\r\n//     {\r\n//         (uint256 tokenUsdPrice, uint8 oraclePriceDecimals) = oracle.getTokenUsdPrice(token);\r\n//         tokenAmountToTransfer = (valueUsd * 10**oraclePriceDecimals) / tokenUsdPrice;\r\n//         tokenAmountToTransfer = fromUniform(tokenAmountToTransfer, token);\r\n//     }\r\n\r\n//     /// @notice Deposit token into batch.\r\n//     /// @notice Tokens not deposited into strategies immediately.\r\n//     /// @param depositToken Supported token to deposit (Must be an NFT).\r\n//     /// @param _amount Amount to deposit.\r\n//     /// @dev User should approve `_amount` of `depositToken` to this contract.\r\n//     /// @dev Only callable by user wallets.\r\n//     function deposit(\r\n//         address depositor,\r\n//         address depositToken,\r\n//         uint256 _amount,\r\n//         uint256 _currentCycleId\r\n//     ) external onlyStrategyRouter {\r\n//         if (!supportsToken(depositToken)) revert UnsupportedToken();\r\n//         (uint256 price, uint8 priceDecimals) = oracle.getTokenUsdPrice(depositToken);\r\n//         uint256 depositedUsd = toUniform((_amount * price) / 10**priceDecimals, depositToken);\r\n//         if (minDeposit > depositedUsd) revert DepositUnderMinimum();\r\n\r\n//         uint256 amountUniform = toUniform(_amount, depositToken);\r\n\r\n//         receiptContract.mint(_currentCycleId, amountUniform, depositToken, depositor);\r\n//     }\r\n\r\n//     function transfer(\r\n//         address token,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) external onlyStrategyRouter {\r\n//         ERC20(token).transfer(to, amount);\r\n//     }\r\n\r\n//     // Admin functions\r\n\r\n//     /// @notice Minimum to be deposited in the batch.\r\n//     /// @param amount Amount of usd, must be `UNIFORM_DECIMALS` decimals.\r\n//     /// @dev Admin function.\r\n//     function setMinDepositUsd(uint256 amount) external onlyStrategyRouter {\r\n//         minDeposit = amount;\r\n//     }\r\n\r\n//     /// @notice Rebalance batch, so that token balances will match strategies weight.\r\n//     /// @return balances Amounts to be deposited in strategies, balanced according to strategies weights.\r\n//     function rebalance() public onlyStrategyRouter returns (uint256[] memory balances) {\r\n//         /*\r\n//         1 store supported-tokens (set of unique addresses)\r\n//             [a,b,c]\r\n//         2 store their balances\r\n//             [10, 6, 8]\r\n//         3 store their sum with uniform decimals\r\n//             24\r\n//         4 create array of length = supported_tokens + strategies_tokens (e.g. [a])\r\n//             [a, b, c] + [a] = 4\r\n//         5 store in that array balances from step 2, duplicated tokens should be ignored\r\n//             [10, 0, 6, 8] (instead of [10,10...] we got [10,0...] because first two are both token a)\r\n//         6a get desired balance for every strategy using their weights\r\n//             [12, 0, 4.8, 7.2] (our 1st strategy will get 50%, 2nd and 3rd will get 20% and 30% respectively)\r\n//         6b store amounts that we need to sell or buy for each balance in order to match desired balances\r\n//             toSell [0, 0, 1.2, 0.8]\r\n//             toBuy  [2, 0, 0, 0]\r\n//             these arrays contain amounts with tokens' original decimals\r\n//         7 now sell 'toSell' amounts of respective tokens for 'toBuy' tokens\r\n//             (token to amount connection is derived by index in the array)\r\n//             (also track new strategies balances for cases where 1 token is shared by multiple strategies)\r\n//         */\r\n//         uint256 totalInBatch;\r\n\r\n//         // point 1\r\n//         uint256 supportedTokensCount = supportedTokens.length();\r\n//         address[] memory _tokens = new address[](supportedTokensCount);\r\n//         uint256[] memory _balances = new uint256[](supportedTokensCount);\r\n\r\n//         // point 2\r\n//         for (uint256 i; i < supportedTokensCount; i++) {\r\n//             _tokens[i] = supportedTokens.at(i);\r\n//             _balances[i] = ERC20(_tokens[i]).balanceOf(address(this));\r\n\r\n//             // point 3\r\n//             totalInBatch += toUniform(_balances[i], _tokens[i]);\r\n//         }\r\n\r\n//         // point 4\r\n//         uint256 strategiesCount = router.getStrategiesCount();\r\n\r\n//         uint256[] memory _strategiesAndSupportedTokensBalances = new uint256[](strategiesCount + supportedTokensCount);\r\n\r\n//         // point 5\r\n//         // We fill in strategies balances with tokens that strategies are accepting and ignoring duplicates\r\n//         for (uint256 i; i < strategiesCount; i++) {\r\n//             address depositToken = router.getStrategyDepositToken(i);\r\n//             for (uint256 j; j < supportedTokensCount; j++) {\r\n//                 if (depositToken == _tokens[j] && _balances[j] > 0) {\r\n//                     _strategiesAndSupportedTokensBalances[i] = _balances[j];\r\n//                     _balances[j] = 0;\r\n//                     break;\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         // we fill in strategies balances with balances of remaining tokens that are supported as deposits but are not\r\n//         // accepted in strategies\r\n//         for (uint256 i = strategiesCount; i < _strategiesAndSupportedTokensBalances.length; i++) {\r\n//             _strategiesAndSupportedTokensBalances[i] = _balances[i - strategiesCount];\r\n//         }\r\n\r\n//         // point 6a\r\n//         uint256[] memory toBuy = new uint256[](strategiesCount);\r\n//         uint256[] memory toSell = new uint256[](_strategiesAndSupportedTokensBalances.length);\r\n//         for (uint256 i; i < strategiesCount; i++) {\r\n//             uint256 desiredBalance = (totalInBatch * router.getStrategyPercentWeight(i)) / 1e18;\r\n//             desiredBalance = fromUniform(desiredBalance, router.getStrategyDepositToken(i));\r\n//             // we skip safemath check since we already do comparison in if clauses\r\n//             unchecked {\r\n//                 // point 6b\r\n//                 if (desiredBalance > _strategiesAndSupportedTokensBalances[i]) {\r\n//                     toBuy[i] = desiredBalance - _strategiesAndSupportedTokensBalances[i];\r\n//                 } else if (desiredBalance < _strategiesAndSupportedTokensBalances[i]) {\r\n//                     toSell[i] = _strategiesAndSupportedTokensBalances[i] - desiredBalance;\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         // point 7\r\n//         // all tokens we accept to deposit but are not part of strategies therefore we are going to swap them\r\n//         // to tokens that strategies are accepting\r\n//         for (uint256 i = strategiesCount; i < _strategiesAndSupportedTokensBalances.length; i++) {\r\n//             toSell[i] = _strategiesAndSupportedTokensBalances[i];\r\n//         }\r\n\r\n//         for (uint256 i; i < _strategiesAndSupportedTokensBalances.length; i++) {\r\n//             for (uint256 j; j < strategiesCount; j++) {\r\n//                 // if we are not going to buy this token (nothing to sell), we simply skip to the next one\r\n//                 // if we can sell this token we go into swap routine\r\n//                 // we proceed to swap routine if there is some tokens to buy and some tokens sell\r\n//                 // if found which token to buy and which token to sell we proceed to swap routine\r\n//                 if (toSell[i] > 0 && toBuy[j] > 0) {\r\n//                     // if toSell's 'i' greater than strats-1 (e.g. strats 2, tokens 2, i=2, 2>2-1==true)\r\n//                     // then take supported_token[2-2=0]\r\n//                     // otherwise take strategy_token[0 or 1]\r\n//                     address sellToken = i > strategiesCount - 1\r\n//                         ? _tokens[i - strategiesCount]\r\n//                         : router.getStrategyDepositToken(i);\r\n//                     address buyToken = router.getStrategyDepositToken(j);\r\n\r\n//                     uint256 toSellUniform = toUniform(toSell[i], sellToken);\r\n//                     uint256 toBuyUniform = toUniform(toBuy[j], buyToken);\r\n//                     /*\r\n//                     Weight of strategies is in token amount not usd equivalent\r\n//                     In case of stablecoin depeg an administrative decision will be made to move out of the strategy\r\n//                     that has exposure to depegged stablecoin.\r\n//                     curSell should have sellToken decimals\r\n//                     */\r\n//                     uint256 curSell = toSellUniform > toBuyUniform\r\n//                         ? changeDecimals(toBuyUniform, UNIFORM_DECIMALS, ERC20(sellToken).decimals())\r\n//                         : toSell[i];\r\n\r\n//                     // no need to swap small amounts\r\n//                     if (toUniform(curSell, sellToken) < REBALANCE_SWAP_THRESHOLD) {\r\n//                         toSell[i] = 0;\r\n//                         toBuy[j] -= changeDecimals(curSell, ERC20(sellToken).decimals(), ERC20(buyToken).decimals());\r\n//                         break;\r\n//                     }\r\n//                     uint256 received = _trySwap(curSell, sellToken, buyToken);\r\n\r\n//                     _strategiesAndSupportedTokensBalances[i] -= curSell;\r\n//                     _strategiesAndSupportedTokensBalances[j] += received;\r\n//                     toSell[i] -= curSell;\r\n//                     toBuy[j] -= changeDecimals(curSell, ERC20(sellToken).decimals(), ERC20(buyToken).decimals());\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         _balances = new uint256[](strategiesCount);\r\n//         for (uint256 i; i < strategiesCount; i++) {\r\n//             _balances[i] = _strategiesAndSupportedTokensBalances[i];\r\n//         }\r\n\r\n//         return _balances;\r\n//     }\r\n\r\n//     /// @notice Set token as supported for user deposit and withdraw.\r\n//     /// @dev Admin function.\r\n//     function setSupportedToken(address tokenAddress, bool supported) external onlyStrategyRouter {\r\n//         if (supported && supportsToken(tokenAddress)) revert AlreadySupportedToken();\r\n\r\n//         if (supported) {\r\n//             supportedTokens.add(tokenAddress);\r\n//         } else {\r\n//             uint8 len = uint8(router.getStrategiesCount());\r\n//             // don't remove tokens that are in use by active strategies\r\n//             for (uint256 i = 0; i < len; i++) {\r\n//                 if (router.getStrategyDepositToken(i) == tokenAddress) {\r\n//                     revert CantRemoveTokenOfActiveStrategy();\r\n//                 }\r\n//             }\r\n//             supportedTokens.remove(tokenAddress);\r\n//         }\r\n//     }\r\n\r\n//     // Internals\r\n\r\n//     /// @dev Change decimal places of number from `oldDecimals` to `newDecimals`.\r\n//     function changeDecimals(\r\n//         uint256 amount,\r\n//         uint8 oldDecimals,\r\n//         uint8 newDecimals\r\n//     ) private pure returns (uint256) {\r\n//         if (oldDecimals < newDecimals) {\r\n//             return amount * (10**(newDecimals - oldDecimals));\r\n//         } else if (oldDecimals > newDecimals) {\r\n//             return amount / (10**(oldDecimals - newDecimals));\r\n//         }\r\n//         return amount;\r\n//     }\r\n\r\n//     /// @dev Swap tokens if they are different (i.e. not the same token)\r\n//     function _trySwap(\r\n//         uint256 amount, // tokenFromAmount\r\n//         address from, // tokenFrom\r\n//         address to // tokenTo\r\n//     ) private returns (uint256 result) {\r\n//         if (from != to) {\r\n//             IERC20(from).transfer(address(exchange), amount);\r\n//             result = exchange.swap(amount, from, to, address(this));\r\n//             return result;\r\n//         }\r\n//         return amount;\r\n//     }\r\n\r\n//     /// @dev Change decimal places from token decimals to `UNIFORM_DECIMALS`.\r\n//     function toUniform(uint256 amount, address token) private view returns (uint256) {\r\n//         return changeDecimals(amount, ERC20(token).decimals(), UNIFORM_DECIMALS);\r\n//     }\r\n\r\n//     /// @dev Convert decimal places from `UNIFORM_DECIMALS` to token decimals.\r\n//     function fromUniform(uint256 amount, address token) private view returns (uint256) {\r\n//         return changeDecimals(amount, UNIFORM_DECIMALS, ERC20(token).decimals());\r\n//     }\r\n// }\r\n\r\n\r\n// pragma solidity ^0.8.0;\r\n\r\n// contract Moderator is Context, Ownable {\r\n//   mapping(address => bool) public moderators;\r\n\r\n//   /// @custom:oz-upgrades-unsafe-allow constructor\r\n//   constructor() {\r\n//     _setModerator(_msgSender(), true);\r\n//     // lock implementation\r\n//     // _disableInitializers();\r\n//   }\r\n\r\n//   // function __Moderator_init(address mod) internal virtual initializer {\r\n//   //   // __Context_init();\r\n//   //   // __Ownable_init();\r\n//   //   // _setModerator(mod, true);\r\n//   // }\r\n\r\n//   /**\r\n//     @notice Set wallets that will be moderators.\r\n//     @dev Admin function.\r\n//   */\r\n//   function _setModerator(address moderator, bool isWhitelisted) internal virtual {\r\n//     require(moderator != address(0), \"Zero address\");\r\n//     bool isModerator = _isModerator();\r\n//     if(isWhitelisted) require(!isModerator, \"already whitelisted\");\r\n//     else require(isModerator, \"Not whitelisted\");\r\n//     moderators[moderator] = isWhitelisted;\r\n//   }\r\n\r\n//   /// @notice Whether `who` is a moderator or not\r\n//   function _isModerator() internal virtual returns (bool) {\r\n//     return moderators[_msgSender()];\r\n//   }\r\n\r\n// }\r\n\r\n// interface IStrategy {\r\n//      /* EVENTS */\r\n\r\n//     /// @notice Fires when user deposits in batch.\r\n//     /// @param token Supported token that user want to deposit.\r\n//     /// @param amount Amount of `token` transferred from user.\r\n//     event Deposit(address indexed user, address token, uint256 amount);\r\n//     /// @notice Fires when batch is deposited into strategies.\r\n//     /// @param closedCycleId Index of the cycle that is closed.\r\n//     /// @param amount Sum of different tokens deposited into strategies.\r\n//     event AllocateToStrategies(uint256 indexed closedCycleId, uint256 amount);\r\n//     /// @notice Fires when user withdraw from batch.\r\n//     /// @param token Supported token that user requested to receive after withdraw.\r\n//     /// @param amount Amount of `token` received by user.\r\n//     event WithdrawFromBatch(address indexed user, address token, uint256 amount);\r\n//     /// @notice Fires when user withdraw from strategies.\r\n//     /// @param token Supported token that user requested to receive after withdraw.\r\n//     /// @param amount Amount of `token` received by user.\r\n//     event WithdrawFromStrategies(address indexed user, address token, uint256 amount);\r\n//     /// @notice Fires when user converts his receipt into shares token.\r\n//     /// @param shares Amount of shares received by user.\r\n//     /// @param receiptIds Indexes of the receipts burned.\r\n//     event RedeemReceiptsToShares(address indexed user, uint256 shares, uint256[] receiptIds);\r\n//     /// @notice Fires when moderator converts foreign receipts into shares token.\r\n//     /// @param receiptIds Indexes of the receipts burned.\r\n//     event RedeemReceiptsToSharesByModerators(address indexed moderator, uint256[] receiptIds);\r\n\r\n//     // Events for setters.\r\n//     event SetMinDeposit(uint256 newAmount);\r\n//     event SetCycleDuration(uint256 newDuration);\r\n//     event SetMinUsdPerCycle(uint256 newAmount);\r\n//     event SetFeeAddress(address newAddress);\r\n//     event SetFeePercent(uint256 newPercent);\r\n//     event SetAddresses(\r\n//         Exchange _exchange,\r\n//         IUsdOracle _oracle,\r\n//         SharesToken _sharesToken,\r\n//         Batch _batch,\r\n//         ReceiptNFT _receiptNft\r\n//     );\r\n\r\n//     /* ERRORS */\r\n//     error AmountExceedTotalSupply();\r\n//     error UnsupportedToken();\r\n//     error NotReceiptOwner();\r\n//     error CycleNotClosed();\r\n//     error CycleClosed();\r\n//     error InsufficientShares();\r\n//     error DuplicateStrategy();\r\n//     error CycleNotClosableYet();\r\n//     error AmountNotSpecified();\r\n//     error CantRemoveLastStrategy();\r\n//     error NothingToRebalance();\r\n//     error NotModerator();\r\n//     error NodepositDetected();\r\n\r\n//     struct StrategyInfo {\r\n//         address strategyAddress;\r\n//         address depositToken;\r\n//         uint256 weight;\r\n//     }\r\n\r\n//     struct Cycle {\r\n//         // block.timestamp at which cycle started\r\n//         uint256 startAt;\r\n//         // batch USD value before deposited into strategies\r\n//         uint256 totalDepositedInUsd;\r\n//         // price per share in USD\r\n//         uint256 pricePerShare;\r\n//         // USD value received by strategies\r\n//         uint256 receivedByStrategiesInUsd;\r\n//         // tokens price at time of the deposit to strategies\r\n//         mapping(address => uint256) prices;\r\n//     }\r\n\r\n//     /// @notice Token used to deposit to strategy.\r\n//     function depositToken() external view returns (address);\r\n\r\n//     /// @notice Deposit token to strategy.\r\n//     function deposit(uint256 amount) external;\r\n\r\n//     /// @notice Withdraw tokens from strategy.\r\n//     /// @dev Max withdrawable amount is returned by totalTokens.\r\n//     function withdraw(uint256 amount) external returns (uint256 amountWithdrawn);\r\n\r\n//     /// @notice Harvest rewards and reinvest them.\r\n//     function compound() external;\r\n\r\n//     /// @notice Approximated amount of token on the strategy.\r\n//     function totalTokens() external view returns (uint256);\r\n\r\n//     /// @notice Withdraw all tokens from strategy.\r\n//     function withdrawAll() external returns (uint256 amountWithdrawn);\r\n// }\r\n\r\n// interface IClipSwapFarm {\r\n//   function BONUS_MULTIPLIER (  ) external view returns ( uint256 );\r\n//   function CLIP (  ) external view returns ( address );\r\n//   function CLIPPerBlock (  ) external view returns ( uint256 );\r\n//   function add ( uint256 _allocPoint, address _lpToken, bool _withUpdate ) external;\r\n//   function deposit ( uint256 _pid, uint256 _amount ) external;\r\n//   function depositedClip (  ) external view returns ( uint256 );\r\n//   function devPercent (  ) external view returns ( uint256 );\r\n//   function devaddr (  ) external view returns ( address );\r\n//   function emergencyWithdraw ( uint256 _pid ) external;\r\n//   function enterStaking ( uint256 _amount ) external;\r\n//   function getMultiplier ( uint256 _from, uint256 _to ) external view returns ( uint256 );\r\n//   function lastBlockDevWithdraw (  ) external view returns ( uint256 );\r\n//   function leaveStaking ( uint256 _amount ) external;\r\n//   function massUpdatePools (  ) external;\r\n//   function migrate ( uint256 _pid ) external;\r\n//   function migrator (  ) external view returns ( address );\r\n//   function owner (  ) external view returns ( address );\r\n//   function pendingCLIP ( uint256 _pid, address _user ) external view returns ( uint256 );\r\n//   function percentDec (  ) external view returns ( uint256 );\r\n//   function poolInfo ( uint256 ) external view returns ( address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accCLIPPerShare );\r\n//   function poolLength (  ) external view returns ( uint256 );\r\n//   function refAddr (  ) external view returns ( address );\r\n//   function refPercent (  ) external view returns ( uint256 );\r\n//   function renounceOwnership (  ) external;\r\n//   function safuPercent (  ) external view returns ( uint256 );\r\n//   function safuaddr (  ) external view returns ( address );\r\n//   function set ( uint256 _pid, uint256 _allocPoint, bool _withUpdate ) external;\r\n//   function setDevAddress ( address _devaddr ) external;\r\n//   function setMigrator ( address _migrator ) external;\r\n//   function setRefAddress ( address _refaddr ) external;\r\n//   function setSafuAddress ( address _safuaddr ) external;\r\n//   function stakingPercent (  ) external view returns ( uint256 );\r\n//   function startBlock (  ) external view returns ( uint256 );\r\n//   function totalAllocPoint (  ) external view returns ( uint256 );\r\n//   function transferOwnership ( address newOwner ) external;\r\n//   function updateClipPerBlock ( uint256 newAmount ) external;\r\n//   function updateMultiplier ( uint256 multiplierNumber ) external;\r\n//   function updatePool ( uint256 _pid ) external;\r\n//   function userInfo ( uint256, address ) external view returns ( uint256 amount, uint256 rewardDebt );\r\n//   function withdraw ( uint256 _pid, uint256 _amount ) external;\r\n//   function withdrawDevAndRefFee (  ) external;\r\n//   function myStakedBalance() external view returns(uint256);\r\n// }\r\n\r\n// contract ReceiptNFT is ERC721, Ownable {\r\n\r\n//     error NonExistingToken();\r\n//     error ReceiptAmountCanOnlyDecrease();\r\n//     error NotManager();\r\n//     /// Invalid query range (`start` >= `stop`).\r\n//     error InvalidQueryRange();\r\n\r\n//     struct ReceiptData {\r\n//         uint256 cycleId;\r\n//         uint256 tokenAmountUniform; // in token\r\n//         address token;\r\n//     }\r\n\r\n//     uint256 private _receiptsCounter;\r\n\r\n//     mapping(uint256 => ReceiptData) public receipts;\r\n//     mapping(address => bool) public managers;\r\n\r\n//     modifier onlyManager() {\r\n//         if (managers[msg.sender] == false) revert NotManager();\r\n//         _;\r\n//     }\r\n\r\n//     /// @custom:oz-upgrades-unsafe-allow constructor\r\n//     constructor() {\r\n//         // lock implementation\r\n//         // _disableInitializers();\r\n//         managers[strategyRouter] = true;\r\n//         managers[batch] = true;\r\n//     }\r\n\r\n//     // function initialize(address strategyRouter, address batch) external initializer {\r\n//     //     // __Ownable_init();\r\n//     //     // __UUPSUpgradeable_init();\r\n//     //     // __ERC721_init(\"Receipt NFT\", \"RECEIPT\");\r\n\r\n//     //     managers[strategyRouter] = true;\r\n//     //     managers[batch] = true;\r\n//     // }\r\n\r\n//     // function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n//     function setAmount(uint256 receiptId, uint256 amount) external onlyManager {\r\n//         if (!_exists(receiptId)) revert NonExistingToken();\r\n//         if (receipts[receiptId].tokenAmountUniform < amount) revert ReceiptAmountCanOnlyDecrease();\r\n//         receipts[receiptId].tokenAmountUniform = amount;\r\n//     }\r\n\r\n//     function mint(\r\n//         uint256 cycleId,\r\n//         uint256 amount,\r\n//         address token,\r\n//         address wallet\r\n//     ) external onlyManager {\r\n//         uint256 _receiptId = _receiptsCounter;\r\n//         receipts[_receiptId] = ReceiptData({cycleId: cycleId, token: token, tokenAmountUniform: amount});\r\n//         _mint(wallet, _receiptId);\r\n//         _receiptsCounter++;\r\n//     }\r\n\r\n//     function burn(uint256 receiptId) external onlyManager {\r\n//         if(!_exists(receiptId)) revert NonExistingToken();\r\n//         _burn(receiptId);\r\n//         delete receipts[receiptId];\r\n//     }\r\n\r\n//     /// @notice Get receipt data recorded in NFT.\r\n//     function getReceipt(uint256 receiptId) external view returns (ReceiptData memory) {\r\n//         if (_exists(receiptId) == false) revert NonExistingToken();\r\n//         return receipts[receiptId];\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns an array of token IDs owned by `owner`,\r\n//      * in the range [`start`, `stop`].\r\n//      *\r\n//      * This function allows for tokens to be queried if the collection\r\n//      * grows too big for a single call of {ReceiptNFT-getTokensOfOwner}.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - `start <= receiptId < stop`\r\n//      */\r\n//     function getTokensOfOwnerIn(\r\n//         address owner,\r\n//         uint256 start,\r\n//         uint256 stop\r\n//     ) public view returns (uint256[] memory receiptIds) {\r\n//         unchecked {\r\n//             if (start >= stop) revert InvalidQueryRange();\r\n//             uint256 receiptIdsIdx;\r\n//             uint256 stopLimit = _receiptsCounter;\r\n//             // Set `stop = min(stop, stopLimit)`.\r\n//             if (stop > stopLimit) {\r\n//                 // At this point `start` could be greater than `stop`.\r\n//                 stop = stopLimit;\r\n//             }\r\n//             uint256 receiptIdsMaxLength = balanceOf(owner);\r\n//             // Set `receiptIdsMaxLength = min(balanceOf(owner), stop - start)`,\r\n//             // to cater for cases where `balanceOf(owner)` is too big.\r\n//             if (start < stop) {\r\n//                 uint256 rangeLength = stop - start;\r\n//                 if (rangeLength < receiptIdsMaxLength) {\r\n//                     receiptIdsMaxLength = rangeLength;\r\n//                 }\r\n//             } else {\r\n//                 receiptIdsMaxLength = 0;\r\n//             }\r\n//             receiptIds = new uint256[](receiptIdsMaxLength);\r\n//             if (receiptIdsMaxLength == 0) {\r\n//                 return receiptIds;\r\n//             }\r\n\r\n//             // We want to scan tokens in range [start <= receiptId < stop].\r\n//             // And if whole range is owned by user or when receiptIdsMaxLength is less than range,\r\n//             // then we also want to exit loop when array is full.\r\n//             uint256 receiptId = start;\r\n//             while (receiptId != stop && receiptIdsIdx != receiptIdsMaxLength) {\r\n//                 if (_exists(receiptId) && ownerOf(receiptId) == owner) {\r\n//                     receiptIds[receiptIdsIdx++] = receiptId;\r\n//                 }\r\n//                 receiptId++;\r\n//             }\r\n\r\n//             // If after scan we haven't filled array, then downsize the array to fit.\r\n//             assembly {\r\n//                 mstore(receiptIds, receiptIdsIdx)\r\n//             }\r\n//             return receiptIds;\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns an array of token IDs owned by `owner`.\r\n//      *\r\n//      * This function scans the ownership mapping and is O(totalSupply) in complexity.\r\n//      * It is meant to be called off-chain.\r\n//      *\r\n//      * See {ReceiptNFT-getTokensOfOwnerIn} for splitting the scan into\r\n//      * multiple smaller scans if the collection is large enough to cause\r\n//      * an out-of-gas error.\r\n//      */\r\n//     function getTokensOfOwner(address owner) public view returns (uint256[] memory receiptIds) {\r\n//         uint256 balance = balanceOf(owner);\r\n//         receiptIds = new uint256[](balance);\r\n//         uint256 receiptId;\r\n\r\n//         while (balance > 0) {\r\n//             if (_exists(receiptId) && ownerOf(receiptId) == owner) {\r\n//                 receiptIds[--balance] = receiptId;\r\n//             }\r\n//             receiptId++;\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n// contract SharesToken is ERC20, Ownable {\r\n\r\n//     error CallerIsNotStrategyRouter();\r\n\r\n//     address private strategyRouter;\r\n\r\n//     modifier onlyStrategyRouter() {\r\n//         if (msg.sender != strategyRouter) revert CallerIsNotStrategyRouter();\r\n//         _;\r\n//     }\r\n\r\n//     /// @custom:oz-upgrades-unsafe-allow constructor\r\n//     constructor() ERC20(\"Clip-Finance Shares\", \"CF\"){\r\n//         // lock implementation\r\n//         // _disableInitializers();\r\n//     }\r\n\r\n//     function initializeState(address _strategyRouter) public onlyOwner {\r\n//         // __Ownable_init();\r\n//         // __UUPSUpgradeable_init();\r\n//         // __ERC20_init(\"Clip-Finance Shares\", \"CF\");\r\n//         strategyRouter = _strategyRouter;\r\n//     }\r\n\r\n//     // function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n//     /// @dev Helper 'transferFrom' function that don't require user approval\r\n//     /// @dev Only callable by strategy router.\r\n//     function transferFromAutoApproved(\r\n//         address from,\r\n//         address to,\r\n//         uint256 amount\r\n//     ) external onlyStrategyRouter {\r\n//         _transfer(from, to, amount);\r\n//     }\r\n\r\n//     function mint(address to, uint256 amount) external onlyStrategyRouter {\r\n//         _mint(to, amount);\r\n//     }\r\n\r\n//     function burn(address from, uint256 amount) external onlyStrategyRouter {\r\n//         _burn(from, amount);\r\n//     }\r\n// }\r\n\r\n\r\n// // import \"hardhat/console.sol\";\r\n\r\n// library StrategyRouterLib {\r\n//     error CycleNotClosed();\r\n\r\n//     uint8 private constant UNIFORM_DECIMALS = 18;\r\n//     uint256 private constant PRECISION = 1e18;\r\n//     // used in rebalance function, UNIFORM_DECIMALS, so 1e17 == 0.1\r\n//     uint256 private constant REBALANCE_SWAP_THRESHOLD = 1e17;\r\n\r\n//     function getStrategiesValue(IUsdOracle oracle, StrategyRouter.StrategyInfo[] storage strategies)\r\n//         public\r\n//         view\r\n//         returns (uint256 totalBalance, uint256[] memory balances)\r\n//     {\r\n//         balances = new uint256[](strategies.length);\r\n//         for (uint256 i; i < balances.length; i++) {\r\n//             address token = strategies[i].depositToken;\r\n\r\n//             uint256 balanceInDepositToken = IStrategy(strategies[i].strategyAddress).totalTokens();\r\n\r\n//             (uint256 price, uint8 priceDecimals) = oracle.getTokenUsdPrice(token);\r\n//             balanceInDepositToken = ((balanceInDepositToken * price) / 10**priceDecimals);\r\n//             balanceInDepositToken = toUniform(balanceInDepositToken, token);\r\n//             balances[i] = balanceInDepositToken;\r\n//             totalBalance += balanceInDepositToken;\r\n//         }\r\n//     }\r\n\r\n//     // returns amount of shares locked by receipt.\r\n//     function calculateSharesFromReceipt(\r\n//         uint256 receiptId,\r\n//         uint256 currentCycleId,\r\n//         ReceiptNFT receiptContract,\r\n//         mapping(uint256 => StrategyRouter.Cycle) storage cycles\r\n//     ) public view returns (uint256 shares) {\r\n//         ReceiptNFT.ReceiptData memory receipt = receiptContract.getReceipt(receiptId);\r\n//         if (receipt.cycleId == currentCycleId) revert CycleNotClosed();\r\n\r\n//         uint256 depositCycleTokenPriceUsd = cycles[receipt.cycleId].prices[receipt.token];\r\n\r\n//         uint256 depositedUsdValueOfReceipt = (receipt.tokenAmountUniform * depositCycleTokenPriceUsd) / PRECISION;\r\n//         assert(depositedUsdValueOfReceipt > 0);\r\n//         // adjust according to what was actually deposited into strategies\r\n//         // example: ($1000 * $4995) / $5000 = $999\r\n//         uint256 allocatedUsdValueOfReceipt = (depositedUsdValueOfReceipt *\r\n//             cycles[receipt.cycleId].receivedByStrategiesInUsd) / cycles[receipt.cycleId].totalDepositedInUsd;\r\n//         return (allocatedUsdValueOfReceipt * PRECISION) / cycles[receipt.cycleId].pricePerShare;\r\n//     }\r\n\r\n//     /// @dev Change decimal places of number from `oldDecimals` to `newDecimals`.\r\n//     function changeDecimals(\r\n//         uint256 amount,\r\n//         uint8 oldDecimals,\r\n//         uint8 newDecimals\r\n//     ) internal pure returns (uint256) {\r\n//         if (oldDecimals < newDecimals) {\r\n//             return amount * (10**(newDecimals - oldDecimals));\r\n//         } else if (oldDecimals > newDecimals) {\r\n//             return amount / (10**(oldDecimals - newDecimals));\r\n//         }\r\n//         return amount;\r\n//     }\r\n\r\n//     /// @dev Swap tokens if they are different (i.e. not the same token)\r\n//     function trySwap(\r\n//         Exchange exchange,\r\n//         uint256 amount,\r\n//         address from,\r\n//         address to\r\n//     ) internal returns (uint256 result) {\r\n//         if (from != to) {\r\n//             IERC20(from).transfer(address(exchange), amount);\r\n//             result = exchange.swap(amount, from, to, address(this));\r\n//             return result;\r\n//         }\r\n//         return amount;\r\n//     }\r\n\r\n//     /// @dev Change decimal places to `UNIFORM_DECIMALS`.\r\n//     function toUniform(uint256 amount, address token) internal view returns (uint256) {\r\n//         return changeDecimals(amount, ERC20(token).decimals(), UNIFORM_DECIMALS);\r\n//     }\r\n\r\n//     /// @dev Convert decimal places from `UNIFORM_DECIMALS` to token decimals.\r\n//     function fromUniform(uint256 amount, address token) internal view returns (uint256) {\r\n//         return changeDecimals(amount, UNIFORM_DECIMALS, ERC20(token).decimals());\r\n//     }\r\n\r\n//     /// @notice receiptIds should be passed here already ordered by their owners in order not to do extra transfers\r\n//     /// @notice Example: [alice, bob, alice, bob] will do 4 transfers. [alice, alice, bob, bob] will do 2 transfers\r\n//     function redeemReceiptsToSharesByModerators(\r\n//         uint256[] calldata receiptIds,\r\n//         uint256 _currentCycleId,\r\n//         ReceiptNFT _receiptContract,\r\n//         SharesToken _sharesToken,\r\n//         mapping(uint256 => StrategyRouter.Cycle) storage cycles\r\n//     ) public {\r\n//         if (receiptIds.length == 0) revert();\r\n//         uint256 sameOwnerShares;\r\n//         // address sameOwnerAddress;\r\n//         for (uint256 i = 0; i < receiptIds.length; i++) {\r\n//             uint256 receiptId = receiptIds[i];\r\n//             uint256 shares = calculateSharesFromReceipt(receiptId, _currentCycleId, _receiptContract, cycles);\r\n//             address receiptOwner = _receiptContract.ownerOf(receiptId);\r\n//             if (i + 1 < receiptIds.length) {\r\n//                 uint256 nextReceiptId = receiptIds[i + 1];\r\n//                 address nextReceiptOwner = _receiptContract.ownerOf(nextReceiptId);\r\n//                 if (nextReceiptOwner == receiptOwner) {\r\n//                     sameOwnerShares += shares;\r\n//                     // sameOwnerAddress = nextReceiptOwner;\r\n//                 } else {\r\n//                     // this is the last receipt in a row of the same owner\r\n//                     sameOwnerShares += shares;\r\n//                     _sharesToken.transfer(receiptOwner, sameOwnerShares);\r\n//                     sameOwnerShares = 0;\r\n//                     // sameOwnerAddress = address(0);\r\n//                 }\r\n//             } else {\r\n//                 // this is the last receipt in the list, if previous owner is different then\r\n//                 // sameOwnerShares is 0, otherwise it contain amount unlocked for that owner\r\n//                 sameOwnerShares += shares;\r\n//                 _sharesToken.transfer(receiptOwner, sameOwnerShares);\r\n//             }\r\n//             _receiptContract.burn(receiptId);\r\n//         }\r\n//     }\r\n\r\n//     /// burn receipts and return amount of shares noted in them.\r\n//     function burnReceipts(\r\n//         uint256[] calldata receiptIds,\r\n//         uint256 _currentCycleId,\r\n//         ReceiptNFT _receiptContract,\r\n//         mapping(uint256 => StrategyRouter.Cycle) storage cycles\r\n//     ) public returns (uint256 shares) {\r\n//         for (uint256 i = 0; i < receiptIds.length; i++) {\r\n//             uint256 receiptId = receiptIds[i];\r\n//             if (_receiptContract.ownerOf(receiptId) != msg.sender) revert StrategyRouter.NotReceiptOwner();\r\n//             shares += calculateSharesFromReceipt(receiptId, _currentCycleId, _receiptContract, cycles);\r\n//             _receiptContract.burn(receiptId);\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Returns strategy weight as percent of total weight.\r\n//     function getStrategyPercentWeight(uint256 _strategyId, StrategyRouter.StrategyInfo[] storage strategies)\r\n//         internal\r\n//         view\r\n//         returns (uint256 strategyPercentAllocation)\r\n//     {\r\n//         uint256 totalStrategyWeight;\r\n//         uint256 len = strategies.length;\r\n//         for (uint256 i; i < len; i++) {\r\n//             totalStrategyWeight += strategies[i].weight;\r\n//         }\r\n//         strategyPercentAllocation = (strategies[_strategyId].weight * PRECISION) / totalStrategyWeight;\r\n\r\n//         return strategyPercentAllocation;\r\n//     }\r\n\r\n//     function rebalanceStrategies(Exchange exchange, StrategyRouter.StrategyInfo[] storage strategies)\r\n//         public\r\n//         returns (uint256[] memory balances)\r\n//     {\r\n//         uint256 totalBalance;\r\n\r\n//         uint256 len = strategies.length;\r\n//         if (len < 2) revert StrategyRouter.NothingToRebalance();\r\n//         uint256[] memory _strategiesBalances = new uint256[](len);\r\n//         address[] memory _strategiesTokens = new address[](len);\r\n//         address[] memory _strategies = new address[](len);\r\n//         for (uint256 i; i < len; i++) {\r\n//             _strategiesTokens[i] = strategies[i].depositToken;\r\n//             _strategies[i] = strategies[i].strategyAddress;\r\n//             _strategiesBalances[i] = IStrategy(_strategies[i]).totalTokens();\r\n//             totalBalance += toUniform(_strategiesBalances[i], _strategiesTokens[i]);\r\n//         }\r\n\r\n//         uint256[] memory toAdd = new uint256[](len);\r\n//         uint256[] memory toSell = new uint256[](len);\r\n//         for (uint256 i; i < len; i++) {\r\n//             uint256 desiredBalance = (totalBalance * getStrategyPercentWeight(i, strategies)) / PRECISION;\r\n//             desiredBalance = fromUniform(desiredBalance, _strategiesTokens[i]);\r\n//             unchecked {\r\n//                 if (desiredBalance > _strategiesBalances[i]) {\r\n//                     toAdd[i] = desiredBalance - _strategiesBalances[i];\r\n//                 } else if (desiredBalance < _strategiesBalances[i]) {\r\n//                     toSell[i] = _strategiesBalances[i] - desiredBalance;\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         _rebalanceStrategies(len, exchange, toSell, toAdd, _strategiesTokens, _strategies);\r\n\r\n//         for (uint256 i; i < len; i++) {\r\n//             _strategiesBalances[i] = IStrategy(_strategies[i]).totalTokens();\r\n//             totalBalance += toUniform(_strategiesBalances[i], _strategiesTokens[i]);\r\n//         }\r\n\r\n//         return _strategiesBalances;\r\n//     }\r\n\r\n//     function _rebalanceStrategies(\r\n//         uint256 len,\r\n//         Exchange exchange,\r\n//         uint256[] memory toSell,\r\n//         uint256[] memory toAdd,\r\n//         address[] memory _strategiesTokens,\r\n//         address[] memory _strategies\r\n//     ) internal {\r\n//         for (uint256 i; i < len; i++) {\r\n//             for (uint256 j; j < len; j++) {\r\n//                 if (toSell[i] == 0) break;\r\n//                 if (toAdd[j] > 0) {\r\n//                     address sellToken = _strategiesTokens[i];\r\n//                     address buyToken = _strategiesTokens[j];\r\n//                     uint256 sellUniform = toUniform(toSell[i], sellToken);\r\n//                     uint256 addUniform = toUniform(toAdd[j], buyToken);\r\n//                     // curSell should have sellToken decimals\r\n//                     uint256 curSell = sellUniform > addUniform\r\n//                         ? changeDecimals(addUniform, UNIFORM_DECIMALS, ERC20(sellToken).decimals())\r\n//                         : toSell[i];\r\n\r\n//                     if (sellUniform < REBALANCE_SWAP_THRESHOLD) {\r\n//                         toSell[i] = 0;\r\n//                         toAdd[j] -= changeDecimals(curSell, ERC20(sellToken).decimals(), ERC20(buyToken).decimals());\r\n//                         break;\r\n//                     }\r\n\r\n//                     uint256 received = IStrategy(_strategies[i]).withdraw(curSell);\r\n//                     received = trySwap(exchange, received, sellToken, buyToken);\r\n//                     ERC20(buyToken).transfer(_strategies[j], received);\r\n//                     IStrategy(_strategies[j]).deposit(received);\r\n\r\n//                     toSell[i] -= curSell;\r\n//                     toAdd[j] -= changeDecimals(curSell, ERC20(sellToken).decimals(), ERC20(buyToken).decimals());\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n// /// @custom:oz-upgrades-unsafe-allow external-library-linking\r\n// contract StrategyRouter is  Moderator {\r\n//     /* EVENTS */\r\n\r\n//     /// @notice Fires when user deposits in batch.\r\n//     /// @param token Supported token that user want to deposit.\r\n//     /// @param amount Amount of `token` transferred from user.\r\n//     event Deposit(address indexed user, address token, uint256 amount);\r\n//     /// @notice Fires when batch is deposited into strategies.\r\n//     /// @param closedCycleId Index of the cycle that is closed.\r\n//     /// @param amount Sum of different tokens deposited into strategies.\r\n//     event AllocateToStrategies(uint256 indexed closedCycleId, uint256 amount);\r\n//     /// @notice Fires when user withdraw from batch.\r\n//     /// @param token Supported token that user requested to receive after withdraw.\r\n//     /// @param amount Amount of `token` received by user.\r\n//     event WithdrawFromBatch(address indexed user, address token, uint256 amount);\r\n//     /// @notice Fires when user withdraw from strategies.\r\n//     /// @param token Supported token that user requested to receive after withdraw.\r\n//     /// @param amount Amount of `token` received by user.\r\n//     event WithdrawFromStrategies(address indexed user, address token, uint256 amount);\r\n//     /// @notice Fires when user converts his receipt into shares token.\r\n//     /// @param shares Amount of shares received by user.\r\n//     /// @param receiptIds Indexes of the receipts burned.\r\n//     event RedeemReceiptsToShares(address indexed user, uint256 shares, uint256[] receiptIds);\r\n//     /// @notice Fires when moderator converts foreign receipts into shares token.\r\n//     /// @param receiptIds Indexes of the receipts burned.\r\n//     event RedeemReceiptsToSharesByModerators(address indexed moderator, uint256[] receiptIds);\r\n\r\n//     // Events for setters.\r\n//     event SetMinDeposit(uint256 newAmount);\r\n//     event SetCycleDuration(uint256 newDuration);\r\n//     event SetMinUsdPerCycle(uint256 newAmount);\r\n//     event SetFeeAddress(address newAddress);\r\n//     event SetFeePercent(uint256 newPercent);\r\n//     event SetAddresses(\r\n//         Exchange _exchange,\r\n//         IUsdOracle _oracle,\r\n//         SharesToken _sharesToken,\r\n//         Batch _batch,\r\n//         ReceiptNFT _receiptNft\r\n//     );\r\n\r\n//     /* ERRORS */\r\n//     error AmountExceedTotalSupply();\r\n//     error UnsupportedToken();\r\n//     error NotReceiptOwner();\r\n//     error CycleNotClosed();\r\n//     error CycleClosed();\r\n//     error InsufficientShares();\r\n//     error DuplicateStrategy();\r\n//     error CycleNotClosableYet();\r\n//     error AmountNotSpecified();\r\n//     error CantRemoveLastStrategy();\r\n//     error NothingToRebalance();\r\n//     error NotModerator();\r\n\r\n//     struct StrategyInfo {\r\n//         address strategyAddress;\r\n//         address depositToken;\r\n//         uint256 weight;\r\n//     }\r\n\r\n//     struct Cycle {\r\n//         // block.timestamp at which cycle started\r\n//         uint256 startAt;\r\n//         // batch USD value before deposited into strategies\r\n//         uint256 totalDepositedInUsd;\r\n//         // price per share in USD\r\n//         uint256 pricePerShare;\r\n//         // USD value received by strategies\r\n//         uint256 receivedByStrategiesInUsd;\r\n//         // tokens price at time of the deposit to strategies\r\n//         mapping(address => uint256) prices;\r\n//     }\r\n\r\n//     uint8 private constant UNIFORM_DECIMALS = 18;\r\n//     uint256 private constant PRECISION = 1e18;\r\n\r\n//     uint256 public cycleDuration;\r\n//     uint256 public minUsdPerCycle;\r\n//     uint256 public minDeposit;\r\n//     uint256 public feePercent;\r\n//     uint256 public currentCycleId;\r\n\r\n//     ReceiptNFT private receiptContract;\r\n//     Exchange public exchange;\r\n//     IUsdOracle private oracle;\r\n//     SharesToken private sharesToken;\r\n//     Batch private batch;\r\n//     address public feeAddress;\r\n\r\n//     StrategyInfo[] public strategies;\r\n//     mapping(uint256 => Cycle) public cycles;\r\n\r\n//     modifier onlyModerators() {\r\n//         if (!_isModerator()) revert NotModerator();\r\n//         _;\r\n//     }\r\n\r\n//     /// @custom:oz-upgrades-unsafe-allow constructor\r\n//     constructor() {\r\n//         // lock implementation\r\n//         // _disableInitializers();\r\n//     }\r\n\r\n//     function initializeState() public onlyOwner {\r\n//         // __Ownable_init();\r\n//         // __UUPS_init();\r\n//         // __Moderator_init(msg.sender);\r\n\r\n//         cycles[0].startAt = block.timestamp;\r\n//         cycleDuration = 1 days;\r\n//     }\r\n\r\n//     function setAddresses(\r\n//         Exchange _exchange,\r\n//         IUsdOracle _oracle,\r\n//         SharesToken _sharesToken,\r\n//         Batch _batch,\r\n//         ReceiptNFT _receiptNft\r\n//     ) external onlyOwner {\r\n//         exchange = _exchange;\r\n//         oracle = _oracle;\r\n//         sharesToken = _sharesToken;\r\n//         batch = _batch;\r\n//         receiptContract = _receiptNft;\r\n//         emit SetAddresses(_exchange, _oracle, _sharesToken, _batch, _receiptNft);\r\n//     }\r\n\r\n//     // function _authorizeUpgrade(address newImplementation) internal override onlyOwner {}\r\n\r\n//     /**\r\n//         Universal Functions\r\n\r\n//         @notice Send pending money collected in the batch into the strategies.\r\n//         @notice Can be called when `cycleDuration` seconds has been passed or\r\n//                 batch usd value has reached `minUsdPerCycle`.\r\n//     */\r\n//     function allocateToStrategies() external {\r\n//         /*\r\n//         step 1 - preparing data and assigning local variables for later reference\r\n//         step 2 - check requirements to launch a cycle\r\n//             condition #1: at least `cycleDuration` time must be passed\r\n//             condition #2: deposit in the current cycle are more than minimum threshold\r\n//         step 3 - store USD price of supported tokens as cycle information\r\n//         step 4 - collect yield and re-deposit/re-stake depending on strategy\r\n//         step 5 - rebalance token in batch to match our desired strategies ratio\r\n//         step 6 - batch transfers funds to strategies and strategies deposit tokens to their respective farms\r\n//         step 7 - we calculate share price for the current cycle and calculate a new amount of shares to issue\r\n//         step 8 - store remaining information for the current cycle\r\n//         */\r\n//         // step 1\r\n//         uint256 _currentCycleId = currentCycleId;\r\n//         (uint256 batchValueInUsd, ) = getBatchValueUsd();\r\n\r\n//         // step 2\r\n//         if (cycles[_currentCycleId].startAt + cycleDuration > block.timestamp && batchValueInUsd < minUsdPerCycle)\r\n//             revert CycleNotClosableYet();\r\n\r\n//         // step 3\r\n//         {\r\n//             address[] memory tokens = getSupportedTokens();\r\n//             for (uint256 i = 0; i < tokens.length; i++) {\r\n//                 if (ERC20(tokens[i]).balanceOf(address(batch)) > 0) {\r\n//                     (uint256 priceUsd, uint8 priceDecimals) = oracle.getTokenUsdPrice(tokens[i]);\r\n//                     cycles[_currentCycleId].prices[tokens[i]] = StrategyRouterLib.changeDecimals(\r\n//                         priceUsd,\r\n//                         priceDecimals,\r\n//                         UNIFORM_DECIMALS\r\n//                     );\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         // step 4\r\n//         uint256 strategiesLength = strategies.length;\r\n//         for (uint256 i; i < strategiesLength; i++) {\r\n//             IStrategy(strategies[i].strategyAddress).compound();\r\n//         }\r\n\r\n//         // step 5\r\n//         (uint256 balanceAfterCompoundInUsd, ) = getStrategiesValue();\r\n//         uint256[] memory depositAmountsInTokens = batch.rebalance();\r\n\r\n//         // step 6\r\n//         for (uint256 i; i < strategiesLength; i++) {\r\n//             address strategyDepositToken = strategies[i].depositToken;\r\n\r\n//             if (depositAmountsInTokens[i] > 0) {\r\n//                 batch.transfer(strategyDepositToken, strategies[i].strategyAddress, depositAmountsInTokens[i]);\r\n\r\n//                 IStrategy(strategies[i].strategyAddress).deposit(depositAmountsInTokens[i]);\r\n//             }\r\n//         }\r\n\r\n//         // step 7\r\n//         (uint256 balanceAfterDepositInUsd, ) = getStrategiesValue();\r\n//         uint256 receivedByStrategiesInUsd = balanceAfterDepositInUsd - balanceAfterCompoundInUsd;\r\n\r\n//         uint256 totalShares = sharesToken.totalSupply();\r\n//         if (totalShares == 0) {\r\n//             sharesToken.mint(address(this), receivedByStrategiesInUsd);\r\n//             cycles[_currentCycleId].pricePerShare = (balanceAfterDepositInUsd * PRECISION) / sharesToken.totalSupply();\r\n//         } else {\r\n//             cycles[_currentCycleId].pricePerShare = (balanceAfterCompoundInUsd * PRECISION) / totalShares;\r\n\r\n//             uint256 newShares = (receivedByStrategiesInUsd * PRECISION) / cycles[_currentCycleId].pricePerShare;\r\n//             sharesToken.mint(address(this), newShares);\r\n//         }\r\n\r\n//         // step 8\r\n//         cycles[_currentCycleId].receivedByStrategiesInUsd = receivedByStrategiesInUsd;\r\n//         cycles[_currentCycleId].totalDepositedInUsd = batchValueInUsd;\r\n\r\n//         emit AllocateToStrategies(_currentCycleId, receivedByStrategiesInUsd);\r\n//         // start new cycle\r\n//         ++currentCycleId;\r\n//         cycles[_currentCycleId].startAt = block.timestamp;\r\n//     }\r\n\r\n//     /**\r\n//         @notice Harvest yield from farms, and reinvest these rewards into strategies.\r\n//         @notice Part of the harvested rewards is taken as protocol comission.\r\n//     */\r\n//     function compoundAll() external {\r\n//         if (sharesToken.totalSupply() == 0) revert();\r\n\r\n//         uint256 len = strategies.length;\r\n//         for (uint256 i; i < len; i++) {\r\n//             IStrategy(strategies[i].strategyAddress).compound();\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Returns list of supported tokens.\r\n//     function getSupportedTokens() public view returns (address[] memory) {\r\n//         return batch.getSupportedTokens();\r\n//     }\r\n\r\n//     /// @dev Returns strategy weight as percent of total weight.\r\n//     function getStrategyPercentWeight(uint256 _strategyId) public view returns (uint256 strategyPercentAllocation) {\r\n//         return StrategyRouterLib.getStrategyPercentWeight(_strategyId, strategies);\r\n//     }\r\n\r\n//     /// @notice Returns count of strategies.\r\n//     function getStrategiesCount() public view returns (uint256 count) {\r\n//         return strategies.length;\r\n//     }\r\n\r\n//     /// @notice Returns array of strategies.\r\n//     function getStrategies() public view returns (StrategyInfo[] memory) {\r\n//         return strategies;\r\n//     }\r\n\r\n//     /// @notice Returns deposit token of the strategy.\r\n//     function getStrategyDepositToken(uint256 i) public view returns (address) {\r\n//         return strategies[i].depositToken;\r\n//     }\r\n\r\n//     /// @notice Returns usd value of the token balances and their sum in the strategies.\r\n//     /// @notice All returned amounts have `UNIFORM_DECIMALS` decimals.\r\n//     /// @return totalBalance Total usd value.\r\n//     /// @return balances Array of usd value of token balances.\r\n//     function getStrategiesValue() public view returns (uint256 totalBalance, uint256[] memory balances) {\r\n//         (totalBalance, balances) = StrategyRouterLib.getStrategiesValue(oracle, strategies);\r\n//     }\r\n\r\n//     /// @notice Returns usd values of the tokens balances and their sum in the batch.\r\n//     /// @notice All returned amounts have `UNIFORM_DECIMALS` decimals.\r\n//     /// @return totalBalance Total batch usd value.\r\n//     /// @return balances Array of usd value of token balances in the batch.\r\n//     function getBatchValueUsd() public view returns (uint256 totalBalance, uint256[] memory balances) {\r\n//         return batch.getBatchValueUsd();\r\n//     }\r\n\r\n//     /// @notice Returns stored address of the `Exchange` contract.\r\n//     function getExchange() public view returns (Exchange) {\r\n//         return exchange;\r\n//     }\r\n\r\n//     /// @notice Calculates amount of redeemable shares by burning receipts.\r\n//     /// @notice Cycle noted in receipts should be closed.\r\n//     function calculateSharesFromReceipts(uint256[] calldata receiptIds) public view returns (uint256 shares) {\r\n//         ReceiptNFT _receiptContract = receiptContract;\r\n//         uint256 _currentCycleId = currentCycleId;\r\n//         for (uint256 i = 0; i < receiptIds.length; i++) {\r\n//             uint256 receiptId = receiptIds[i];\r\n//             shares += StrategyRouterLib.calculateSharesFromReceipt(\r\n//                 receiptId,\r\n//                 _currentCycleId,\r\n//                 _receiptContract,\r\n//                 cycles\r\n//             );\r\n//         }\r\n//     }\r\n\r\n//     /// @notice Reedem shares for receipts on behalf of their owners.\r\n//     /// @notice Cycle noted in receipts should be closed.\r\n//     /// @notice Only callable by moderators.\r\n//     function redeemReceiptsToSharesByModerators(uint256[] calldata receiptIds) public onlyModerators {\r\n//         StrategyRouterLib.redeemReceiptsToSharesByModerators(\r\n//             receiptIds,\r\n//             currentCycleId,\r\n//             receiptContract,\r\n//             sharesToken,\r\n//             cycles\r\n//         );\r\n//         emit RedeemReceiptsToSharesByModerators(msg.sender, receiptIds);\r\n//     }\r\n\r\n//     /// @notice Calculate current usd value of shares.\r\n//     /// @dev Returned amount has `UNIFORM_DECIMALS` decimals.\r\n//     function calculateSharesUsdValue(uint256 amountShares) public view returns (uint256 amountUsd) {\r\n//         uint256 totalShares = sharesToken.totalSupply();\r\n//         if (amountShares > totalShares) revert AmountExceedTotalSupply();\r\n//         (uint256 strategiesLockedUsd, ) = getStrategiesValue();\r\n//         uint256 currentPricePerShare = (strategiesLockedUsd * PRECISION) / totalShares;\r\n\r\n//         return (amountShares * currentPricePerShare) / PRECISION;\r\n//     }\r\n\r\n//     /// @notice Calculate shares amount from usd value.\r\n//     /// @dev Returned amount has `UNIFORM_DECIMALS` decimals.\r\n//     function calculateSharesAmountFromUsdAmount(uint256 amount) public view returns (uint256 shares) {\r\n//         (uint256 strategiesLockedUsd, ) = getStrategiesValue();\r\n//         uint256 currentPricePerShare = (strategiesLockedUsd * PRECISION) / sharesToken.totalSupply();\r\n//         shares = (amount * PRECISION) / currentPricePerShare;\r\n//     }\r\n\r\n//     /// @notice Returns whether this token is supported.\r\n//     /// @param tokenAddress Token address to lookup.\r\n//     function supportsToken(address tokenAddress) public view returns (bool isSupported) {\r\n//         return batch.supportsToken(tokenAddress);\r\n//     }\r\n\r\n//     // User Functions\r\n\r\n//     /// @notice Convert receipts into share tokens.\r\n//     /// @notice Cycle noted in receipt should be closed.\r\n//     /// @return shares Amount of shares redeemed by burning receipts.\r\n//     function redeemReceiptsToShares(uint256[] calldata receiptIds) public returns (uint256 shares) {\r\n//         shares = StrategyRouterLib.burnReceipts(receiptIds, currentCycleId, receiptContract, cycles);\r\n//         sharesToken.transfer(msg.sender, shares);\r\n//         emit RedeemReceiptsToShares(msg.sender, shares, receiptIds);\r\n//     }\r\n\r\n//     /// @notice Withdraw tokens from strategies.\r\n//     /// @notice On partial withdraw leftover shares transferred to user.\r\n//     /// @notice If not enough shares unlocked from receipt, or no receipts are passed, then shares will be taken from user.\r\n//     /// @notice Receipts are burned.\r\n//     /// @notice Cycle noted in receipts should be closed.\r\n//     /// @param receiptIds Array of ReceiptNFT ids.\r\n//     /// @param withdrawToken Supported token that user wish to receive.\r\n//     /// @param shares Amount of shares to withdraw.\r\n//     function withdrawFromStrategies(\r\n//         uint256[] calldata receiptIds,\r\n//         address withdrawToken,\r\n//         uint256 shares\r\n//     ) external {\r\n//         if (shares == 0) revert AmountNotSpecified();\r\n//         if (!supportsToken(withdrawToken)) revert UnsupportedToken();\r\n\r\n//         // uint256 unlockedShares = StrategyRouterLib.burnReceipts(receiptIds, currentCycleId, receiptContract, cycles);\r\n//         ReceiptNFT _receiptContract = receiptContract;\r\n//         uint256 _currentCycleId = currentCycleId;\r\n//         uint256 unlockedShares;\r\n\r\n//         // first try to get all shares from receipts\r\n//         for (uint256 i = 0; i < receiptIds.length; i++) {\r\n//             uint256 receiptId = receiptIds[i];\r\n//             if (_receiptContract.ownerOf(receiptId) != msg.sender) revert NotReceiptOwner();\r\n//             uint256 receiptShares = StrategyRouterLib.calculateSharesFromReceipt(\r\n//                 receiptId,\r\n//                 _currentCycleId,\r\n//                 _receiptContract,\r\n//                 cycles\r\n//             );\r\n//             unlockedShares += receiptShares;\r\n//             if(unlockedShares > shares) {\r\n//                 // receipts fulfilled requested shares and more,  \r\n//                 // so get rid of extra shares and update receipt amount\r\n//                 uint256 leftoverShares = unlockedShares - shares;\r\n//                 unlockedShares -= leftoverShares;\r\n\r\n//                 ReceiptNFT.ReceiptData memory receipt = receiptContract.getReceipt(receiptId);\r\n//                 uint256 newReceiptAmount = receipt.tokenAmountUniform * leftoverShares / receiptShares;\r\n//                 _receiptContract.setAmount(receiptId, newReceiptAmount);\r\n//             } else {\r\n//                 // unlocked shares less or equal to requested, so can take whole receipt amount\r\n//                 _receiptContract.burn(receiptId);\r\n//             }\r\n//             if(unlockedShares == shares) break;\r\n//         }\r\n\r\n//         // if receipts didn't fulfilled requested shares amount, then try to take more from caller \r\n//         if (unlockedShares < shares) {\r\n//             // lack of shares -> get from user\r\n//             sharesToken.transferFromAutoApproved(msg.sender, address(this), shares - unlockedShares);\r\n//         }\r\n\r\n//         // shares into usd using current PPS\r\n//         uint256 usdToWithdraw = calculateSharesUsdValue(shares);\r\n//         sharesToken.burn(address(this), shares);\r\n//         _withdrawFromStrategies(usdToWithdraw, withdrawToken);\r\n//     }\r\n\r\n//     /// @notice Withdraw tokens from batch.\r\n//     /// @notice Receipts are burned and user receives amount of tokens that was noted.\r\n//     /// @notice Cycle noted in receipts should be current cycle.\r\n//     /// @param receiptIds Receipt NFTs ids.\r\n//     function withdrawFromBatch(uint256[] calldata receiptIds) public {\r\n//         batch.withdraw(msg.sender, receiptIds, currentCycleId);\r\n//     }\r\n\r\n//     /// @notice Deposit token into batch.\r\n//     /// @param depositToken Supported token to deposit.\r\n//     /// @param _amount Amount to deposit.\r\n//     /// @dev User should approve `_amount` of `depositToken` to this contract.\r\n//     function depositToBatch(address depositToken, uint256 _amount) external {\r\n//         batch.deposit(msg.sender, depositToken, _amount, currentCycleId);\r\n//         IERC20(depositToken).transferFrom(msg.sender, address(batch), _amount);\r\n//         emit Deposit(msg.sender, depositToken, _amount);\r\n//     }\r\n\r\n//     /**\r\n//         @notice Set token as supported for user deposit and withdraw.\r\n//         @dev Admin function.\r\n//         Note: Dual function that activates and deactivates supported token. \r\n//     */ \r\n//     function setSupportedToken(address tokenAddress, bool supported) external onlyOwner {\r\n//         batch.setSupportedToken(tokenAddress, supported);\r\n//     }\r\n\r\n//     /// @notice Set address for fees collected by protocol.\r\n//     /// @dev Admin function.\r\n//     function setFeesCollectionAddress(address _feeAddress) external onlyOwner {\r\n//         if (_feeAddress == address(0)) revert();\r\n//         feeAddress = _feeAddress;\r\n//         emit SetFeeAddress(_feeAddress);\r\n//     }\r\n\r\n//     /// @notice Set percent to take from harvested rewards as protocol fee.\r\n//     /// @dev Admin function.\r\n//     function setFeesPercent(uint256 percent) external onlyOwner {\r\n//         feePercent = percent;\r\n//         emit SetFeePercent(percent);\r\n//     }\r\n\r\n//     /// @notice Minimum usd needed to be able to close the cycle.\r\n//     /// @param amount Amount of usd, must be `UNIFORM_DECIMALS` decimals.\r\n//     /// @dev Admin function.\r\n//     function setMinUsdPerCycle(uint256 amount) external onlyOwner {\r\n//         minUsdPerCycle = amount;\r\n//         emit SetMinUsdPerCycle(amount);\r\n//     }\r\n\r\n//     /// @notice Minimum to be deposited in the batch.\r\n//     /// @param amount Amount of usd, must be `UNIFORM_DECIMALS` decimals.\r\n//     /// @dev Admin function.\r\n//     function setMinDepositUsd(uint256 amount) external onlyOwner {\r\n//         batch.setMinDepositUsd(amount);\r\n//         emit SetMinDeposit(amount);\r\n//     }\r\n\r\n//     /// @notice Minimum time needed to be able to close the cycle.\r\n//     /// @param duration Duration of cycle in seconds.\r\n//     /// @dev Admin function.\r\n//     function setCycleDuration(uint256 duration) external onlyOwner {\r\n//         cycleDuration = duration;\r\n//         emit SetCycleDuration(duration);\r\n//     }\r\n\r\n//     /// @notice Add strategy.\r\n//     /// @param _strategyAddress Address of the strategy.\r\n//     /// @param _depositTokenAddress Token to be deposited into strategy.\r\n//     /// @param _weight Weight of the strategy. Used to split user deposit between strategies.\r\n//     /// @dev Admin function.\r\n//     /// @dev Deposit token must be supported by the router.\r\n//     function addStrategy(\r\n//         address _strategyAddress,\r\n//         address _depositTokenAddress,\r\n//         uint256 _weight\r\n//     ) external onlyOwner {\r\n//         if (!supportsToken(_depositTokenAddress)) revert UnsupportedToken();\r\n//         uint256 len = strategies.length;\r\n//         for (uint256 i = 0; i < len; i++) {\r\n//             if (strategies[i].strategyAddress == _strategyAddress) revert DuplicateStrategy();\r\n//         }\r\n\r\n//         strategies.push(\r\n//             StrategyInfo({\r\n//                 strategyAddress: _strategyAddress,\r\n//                 depositToken: IStrategy(_strategyAddress).depositToken(),\r\n//                 weight: _weight\r\n//             })\r\n//         );\r\n//     }\r\n\r\n//     /// @notice Update strategy weight.\r\n//     /// @param _strategyId Id of the strategy.\r\n//     /// @param _weight New weight of the strategy.\r\n//     /// @dev Admin function.\r\n//     function updateStrategy(uint256 _strategyId, uint256 _weight) external onlyOwner {\r\n//         strategies[_strategyId].weight = _weight;\r\n//     }\r\n\r\n//     /// @notice Remove strategy and deposit its balance in other strategies.\r\n//     /// @notice Will revert when there is only 1 strategy left.\r\n//     /// @param _strategyId Id of the strategy.\r\n//     /// @dev Admin function.\r\n//     function removeStrategy(uint256 _strategyId) external onlyOwner {\r\n//         if (strategies.length < 2) revert CantRemoveLastStrategy();\r\n//         StrategyInfo memory removedStrategyInfo = strategies[_strategyId];\r\n//         IStrategy removedStrategy = IStrategy(removedStrategyInfo.strategyAddress);\r\n//         address removedDepositToken = removedStrategyInfo.depositToken;\r\n\r\n//         uint256 len = strategies.length - 1;\r\n//         strategies[_strategyId] = strategies[len];\r\n//         strategies.pop();\r\n\r\n//         // compound removed strategy\r\n//         removedStrategy.compound();\r\n\r\n//         // withdraw all from removed strategy\r\n//         uint256 withdrawnAmount = removedStrategy.withdrawAll();\r\n\r\n//         // compound all strategies\r\n//         for (uint256 i; i < len; i++) {\r\n//             IStrategy(strategies[i].strategyAddress).compound();\r\n//         }\r\n\r\n//         // deposit withdrawn funds into other strategies\r\n//         for (uint256 i; i < len; i++) {\r\n//             uint256 depositAmount = (withdrawnAmount * getStrategyPercentWeight(i)) / PRECISION;\r\n//             address strategyDepositToken = strategies[i].depositToken;\r\n\r\n//             depositAmount = StrategyRouterLib.trySwap(\r\n//                 exchange,\r\n//                 depositAmount,\r\n//                 removedDepositToken,\r\n//                 strategyDepositToken\r\n//             );\r\n//             IERC20(strategyDepositToken).transfer(strategies[i].strategyAddress, depositAmount);\r\n//             IStrategy(strategies[i].strategyAddress).deposit(depositAmount);\r\n//         }\r\n//         Ownable(address(removedStrategy)).transferOwnership(msg.sender);\r\n//     }\r\n\r\n//     /// @notice Rebalance batch, so that token balances will match strategies weight.\r\n//     /// @return balances Batch token balances after rebalancing.\r\n//     /// @dev Admin function.\r\n//     function rebalanceBatch() external onlyOwner returns (uint256[] memory balances) {\r\n//         return batch.rebalance();\r\n//     }\r\n\r\n//     /// @notice Rebalance strategies, so that their balances will match their weights.\r\n//     /// @return balances Balances of the strategies after rebalancing.\r\n//     /// @dev Admin function.\r\n//     function rebalanceStrategies() external onlyOwner returns (uint256[] memory balances) {\r\n//         return StrategyRouterLib.rebalanceStrategies(exchange, strategies);\r\n//     }\r\n\r\n//     // Internals\r\n\r\n//     /// @param withdrawAmountUsd - USD value to withdraw. `UNIFORM_DECIMALS` decimals.\r\n//     /// @param withdrawToken Supported token to receive after withdraw.\r\n//     function _withdrawFromStrategies(uint256 withdrawAmountUsd, address withdrawToken) private {\r\n//         (, uint256[] memory strategyTokenBalancesUsd) = getStrategiesValue();\r\n//         uint256 strategiesCount = strategies.length;\r\n\r\n//         uint256 tokenAmountToWithdraw;\r\n\r\n//         // find token to withdraw requested token without extra swaps\r\n//         // otherwise try to find token that is sufficient to fulfill requested amount\r\n//         uint256 supportedTokenId = type(uint256).max; // index of strategy, uint.max means not found\r\n//         for (uint256 i; i < strategiesCount; i++) {\r\n//             address strategyDepositToken = strategies[i].depositToken;\r\n//             if (strategyTokenBalancesUsd[i] >= withdrawAmountUsd) {\r\n//                 supportedTokenId = i;\r\n//                 if (strategyDepositToken == withdrawToken) break;\r\n//             }\r\n//         }\r\n\r\n//         if (supportedTokenId != type(uint256).max) {\r\n//             address tokenAddress = strategies[supportedTokenId].depositToken;\r\n//             (uint256 tokenUsdPrice, uint8 oraclePriceDecimals) = oracle.getTokenUsdPrice(tokenAddress);\r\n\r\n//             // convert usd to token amount\r\n//             tokenAmountToWithdraw = (withdrawAmountUsd * 10**oraclePriceDecimals) / tokenUsdPrice;\r\n//             // convert uniform decimals to token decimas\r\n//             tokenAmountToWithdraw = StrategyRouterLib.fromUniform(tokenAmountToWithdraw, tokenAddress);\r\n\r\n//             // withdraw from strategy\r\n//             tokenAmountToWithdraw = IStrategy(strategies[supportedTokenId].strategyAddress).withdraw(\r\n//                 tokenAmountToWithdraw\r\n//             );\r\n//             // is withdrawn token not the one that's requested?\r\n//             if (tokenAddress != withdrawToken) {\r\n//                 // swap withdrawn token to the requested one\r\n//                 tokenAmountToWithdraw = StrategyRouterLib.trySwap(\r\n//                     exchange,\r\n//                     tokenAmountToWithdraw,\r\n//                     tokenAddress,\r\n//                     withdrawToken\r\n//                 );\r\n//             }\r\n//             withdrawAmountUsd = 0;\r\n//         }\r\n\r\n//         // if we didn't fulfilled withdraw amount above,\r\n//         // swap tokens one by one until withraw amount is fulfilled\r\n//         if (withdrawAmountUsd != 0) {\r\n//             for (uint256 i; i < strategiesCount; i++) {\r\n//                 address tokenAddress = strategies[i].depositToken;\r\n//                 uint256 tokenAmountToSwap;\r\n//                 (uint256 tokenUsdPrice, uint8 oraclePriceDecimals) = oracle.getTokenUsdPrice(tokenAddress);\r\n\r\n//                 // at this moment its in USD\r\n//                 tokenAmountToSwap = strategyTokenBalancesUsd[i] < withdrawAmountUsd\r\n//                     ? strategyTokenBalancesUsd[i]\r\n//                     : withdrawAmountUsd;\r\n//                 unchecked {\r\n//                     withdrawAmountUsd -= tokenAmountToSwap;\r\n//                 }\r\n//                 // convert usd value into token amount\r\n//                 tokenAmountToSwap = (tokenAmountToSwap * 10**oraclePriceDecimals) / tokenUsdPrice;\r\n//                 // adjust decimals of the token amount\r\n//                 tokenAmountToSwap = StrategyRouterLib.fromUniform(tokenAmountToSwap, tokenAddress);\r\n//                 tokenAmountToSwap = IStrategy(strategies[i].strategyAddress).withdraw(tokenAmountToSwap);\r\n//                 // swap for requested token\r\n//                 tokenAmountToWithdraw += StrategyRouterLib.trySwap(\r\n//                     exchange,\r\n//                     tokenAmountToSwap,\r\n//                     tokenAddress,\r\n//                     withdrawToken\r\n//                 );\r\n//                 if (withdrawAmountUsd == 0) break;\r\n//             }\r\n//         }\r\n\r\n//         IERC20(withdrawToken).transfer(msg.sender, tokenAmountToWithdraw);\r\n//         emit WithdrawFromStrategies(msg.sender, withdrawToken, tokenAmountToWithdraw);\r\n//     }\r\n\r\n//     /// @dev Sets new moderator\r\n//     function setModerator(address moderator, bool isWhitelisted) public onlyOwner {\r\n//         _setModerator(moderator, isWhitelisted);\r\n//     }\r\n// }\r\n\r\n\r\n// /** Dodo Exchange USDT Liquidity pool.\r\n//         How is works\r\n//         ------------\r\n//         - USDT is converted to an LP token in the BUSD-USDT Pool on the DODO Exchange\r\n//         - USDT LP token is staked in the BUSD-USDT liquidity mining farm.\r\n//         - Rewards are received as DODO tokens.\r\n//         - DODO tokens are sold for USDT and deposited back into the pool.\r\n           \r\n//         Functions: \r\n//             o deposit()\r\n//             o withdraw()\r\n//             o withdrawall()\r\n//             o compound()\r\n\r\n//         params.clip : Contract of the reward token. (In this case Dodo)\r\n//         param.farm : Liquidity Mining Farm.\r\n\r\n//     @custom:oz-upgrades-unsafe-allow constructor state-variable-immutable\r\n//  */\r\n\r\n// contract DodoStrategy is Ownable, IStrategy {\r\n//     // error CallerUpgrader();\r\n\r\n//     // address internal upgrader;\r\n    \r\n//     ERC20 internal tokenA; // USDT Token to deposit\r\n//     ERC20 internal tokenB; // BUSD \r\n//     ERC20 internal lpToken; // BUSD-USDT LpToken\r\n//     StrategyRouter internal strategyRouter; // StrategyRouter contract\r\n\r\n//     ERC20 internal constant dodo = ERC20(0x67ee3Cb086F8a16f34beE3ca72FAD36F7Db929e2); //reward token\r\n//     IClipSwapFarm internal farm; // Dodo farm\r\n//     IUniswapV2Router02 internal dodoRouter;  // Dodo Exchange\r\n\r\n//     uint256 internal poolId;\r\n\r\n//     uint256 private LEFTOVER_THRESHOLD_TOKEN_A;\r\n//     uint256 private LEFTOVER_THRESHOLD_TOKEN_B;\r\n//     uint256 private constant PERCENT_DENOMINATOR = 10000;\r\n\r\n//     // modifier onlyUpgrader() {\r\n//     //     if (msg.sender != address(upgrader)) revert CallerUpgrader();\r\n//     //     _;\r\n//     // }\r\n\r\n//     /// @dev construct is intended to initialize immutables on implementation\r\n//     constructor() {\r\n//         // lock implementation\r\n//         // _disableInitializers();\r\n//     }\r\n\r\n//     function initializeState(\r\n//         // address _upgrader,\r\n//         StrategyRouter _strategyRouter,\r\n//         uint256 _poolId,\r\n//         ERC20 _tokenA,\r\n//         ERC20 _tokenB,\r\n//         ERC20 _lpToken,\r\n//         address _farm,\r\n//         address _dodoRouter\r\n//     ) external onlyOwner {\r\n//         // __Ownable_init();\r\n//         // __UUPSUpgradeable_init();\r\n//         // upgrader = _upgrader;\r\n//         strategyRouter = _strategyRouter;\r\n//         poolId = _poolId;\r\n//         tokenA = _tokenA;\r\n//         tokenB = _tokenB;\r\n//         lpToken = _lpToken;\r\n//         farm = IClipSwapFarm(_farm);\r\n//         dodoRouter = IUniswapV2Router02(_dodoRouter);\r\n//         LEFTOVER_THRESHOLD_TOKEN_A = 10**_tokenA.decimals();\r\n//         LEFTOVER_THRESHOLD_TOKEN_B = 10**_tokenB.decimals();\r\n//     }\r\n\r\n//     // function _authorizeUpgrade(address newImplementation) internal override onlyUpgrader {}\r\n\r\n//     function depositToken() external view override returns (address) {\r\n//         return address(tokenA);\r\n//     }\r\n\r\n//     function deposit(uint256 amount) external override onlyOwner {\r\n//         Exchange exchange = strategyRouter.getExchange();\r\n\r\n//         // uint256 dexFee = exchange.getFee(amount / 2, address(tokenA), address(tokenB));\r\n//         uint256 amountB = calculateSwapAmount(amount / 2, 0);\r\n//         // uint256 amountB = calculateSwapAmount(amount / 2);\r\n//         uint256 amountA = amount - amountB;\r\n\r\n//         tokenA.transfer(address(exchange), amountB);\r\n//         amountB = exchange.swap(amountB, address(tokenA), address(tokenB), address(this));\r\n\r\n//         tokenA.approve(address(dodoRouter), amountA);\r\n//         tokenB.approve(address(dodoRouter), amountB);\r\n//         (, , uint256 liquidity) = dodoRouter.addLiquidity(\r\n//             address(tokenA),\r\n//             address(tokenB),\r\n//             amountA,\r\n//             amountB,\r\n//             0,\r\n//             0,\r\n//             address(this),\r\n//             block.timestamp\r\n//         );\r\n\r\n//         lpToken.approve(address(farm), liquidity);\r\n//         farm.deposit(poolId, liquidity);\r\n//     }\r\n\r\n//     function withdraw(uint256 strategyTokenAmountToWithdraw)\r\n//         external\r\n//         override\r\n//         onlyOwner\r\n//         returns (uint256 amountWithdrawn)\r\n//     {\r\n//         address token0 = IUniswapV2Pair(address(lpToken)).token0();\r\n//         address token1 = IUniswapV2Pair(address(lpToken)).token1();\r\n//         uint256 balance0 = IERC20(token0).balanceOf(address(lpToken));\r\n//         uint256 balance1 = IERC20(token1).balanceOf(address(lpToken));\r\n\r\n//         uint256 amountA = strategyTokenAmountToWithdraw / 2;\r\n//         uint256 amountB = strategyTokenAmountToWithdraw - amountA;\r\n\r\n//         (balance0, balance1) = token0 == address(tokenA) ? (balance0, balance1) : (balance1, balance0);\r\n\r\n//         amountB = dodoRouter.quote(amountB, balance0, balance1);\r\n\r\n//         uint256 liquidityToRemove = (lpToken.totalSupply() * (amountA + amountB)) / (balance0 + balance1);\r\n\r\n//         farm.withdraw(poolId, liquidityToRemove);\r\n//         lpToken.approve(address(dodoRouter), liquidityToRemove);\r\n//         (amountA, amountB) = dodoRouter.removeLiquidity(\r\n//             address(tokenA),\r\n//             address(tokenB),\r\n//             lpToken.balanceOf(address(this)),\r\n//             0,\r\n//             0,\r\n//             address(this),\r\n//             block.timestamp\r\n//         );\r\n\r\n//         Exchange exchange = strategyRouter.getExchange();\r\n//         tokenB.approve(address(exchange), amountB);\r\n//         amountA += exchange.swap(amountB, address(tokenB), address(tokenA), address(this));\r\n//         tokenA.transfer(msg.sender, amountA);\r\n//         return amountA;\r\n//     }\r\n\r\n//     function compound() external override onlyOwner {\r\n//         // inside withdraw happens DODO rewards collection\r\n//         farm.withdraw(poolId, 0);\r\n//         // use balance because DODO is harvested on deposit and withdraw calls\r\n//         uint256 dodoAmount = dodo.balanceOf(address(this));\r\n\r\n//         if (dodoAmount > 0) {\r\n//             fix_leftover(0);\r\n//             sellReward(dodoAmount);\r\n//             uint256 balanceA = tokenA.balanceOf(address(this));\r\n//             uint256 balanceB = tokenB.balanceOf(address(this));\r\n\r\n//             tokenA.approve(address(dodoRouter), balanceA);\r\n//             tokenB.approve(address(dodoRouter), balanceB);\r\n\r\n//             dodoRouter.addLiquidity(\r\n//                 address(tokenA),\r\n//                 address(tokenB),\r\n//                 balanceA,\r\n//                 balanceB,\r\n//                 0,\r\n//                 0,\r\n//                 address(this),\r\n//                 block.timestamp\r\n//             );\r\n\r\n//             uint256 lpAmount = lpToken.balanceOf(address(this));\r\n//             lpToken.approve(address(farm), lpAmount);\r\n//             farm.deposit(poolId, lpAmount);\r\n//         }\r\n//     }\r\n\r\n//     function totalTokens() external view override returns (uint256) {\r\n//         (uint256 liquidity, ) = farm.userInfo(poolId, address(this));\r\n\r\n//         uint256 _totalSupply = lpToken.totalSupply();\r\n//         // this formula is from uniswap.remove_liquidity -> uniswapPair.burn function\r\n//         uint256 balanceA = tokenA.balanceOf(address(lpToken));\r\n//         uint256 balanceB = tokenB.balanceOf(address(lpToken));\r\n//         uint256 amountA = (liquidity * balanceA) / _totalSupply;\r\n//         uint256 amountB = (liquidity * balanceB) / _totalSupply;\r\n\r\n//         if (amountB > 0) {\r\n//             address token0 = IUniswapV2Pair(address(lpToken)).token0();\r\n\r\n//             (uint256 _reserve0, uint256 _reserve1) = token0 == address(tokenB)\r\n//                 ? (balanceB, balanceA)\r\n//                 : (balanceA, balanceB);\r\n\r\n//             // convert amountB to amount tokenA\r\n//             amountA += dodoRouter.quote(amountB, _reserve0, _reserve1);\r\n//         }\r\n\r\n//         return amountA;\r\n//     }\r\n\r\n//     function withdrawAll() external override onlyOwner returns (uint256 amountWithdrawn) {\r\n//         (uint256 amount, ) = farm.userInfo(poolId, address(this));\r\n//         if (amount > 0) {\r\n//             farm.withdraw(poolId, amount);\r\n//             uint256 lpAmount = lpToken.balanceOf(address(this));\r\n//             lpToken.approve(address(dodoRouter), lpAmount);\r\n//             dodoRouter.removeLiquidity(\r\n//                 address(tokenA),\r\n//                 address(tokenB),\r\n//                 lpToken.balanceOf(address(this)),\r\n//                 0,\r\n//                 0,\r\n//                 address(this),\r\n//                 block.timestamp\r\n//             );\r\n//         }\r\n\r\n//         uint256 amountA = tokenA.balanceOf(address(this));\r\n//         uint256 amountB = tokenB.balanceOf(address(this));\r\n\r\n//         if (amountB > 0) {\r\n//             Exchange exchange = strategyRouter.getExchange();\r\n//             tokenB.transfer(address(exchange), amountB);\r\n//             amountA += exchange.swap(amountB, address(tokenB), address(tokenA), address(this));\r\n//         }\r\n//         if (amountA > 0) {\r\n//             tokenA.transfer(msg.sender, amountA);\r\n//             return amountA;\r\n//         }\r\n//     }\r\n\r\n//     /// @dev Swaps leftover tokens for a better ratio for LP.\r\n//     function fix_leftover(uint256 amountIgnore) private {\r\n//         Exchange exchange = strategyRouter.getExchange();\r\n//         uint256 amountB = tokenB.balanceOf(address(this));\r\n//         uint256 amountA = tokenA.balanceOf(address(this)) - amountIgnore;\r\n//         uint256 toSwap;\r\n//         if (amountB > amountA && (toSwap = amountB - amountA) > LEFTOVER_THRESHOLD_TOKEN_B) {\r\n//             uint256 dexFee = exchange.getFee(toSwap / 2, address(tokenA), address(tokenB));\r\n//             toSwap = calculateSwapAmount(toSwap / 2, dexFee);\r\n//             tokenB.transfer(address(exchange), toSwap);\r\n//             exchange.swap(toSwap, address(tokenB), address(tokenA), address(this));\r\n//         } else if (amountA > amountB && (toSwap = amountA - amountB) > LEFTOVER_THRESHOLD_TOKEN_A) {\r\n//             uint256 dexFee = exchange.getFee(toSwap / 2, address(tokenA), address(tokenB));\r\n//             toSwap = calculateSwapAmount(toSwap / 2, dexFee);\r\n//             tokenA.transfer(address(exchange), toSwap);\r\n//             exchange.swap(toSwap, address(tokenA), address(tokenB), address(this));\r\n//         }\r\n//     }\r\n\r\n//     // swap dodo for tokenA & tokenB in proportions 50/50\r\n//     function sellReward(uint256 dodoAmount) private returns (uint256 receivedA, uint256 receivedB) {\r\n//         // sell for lp ratio\r\n//         uint256 amountA = dodoAmount / 2;\r\n//         uint256 amountB = dodoAmount - amountA;\r\n\r\n//         Exchange exchange = strategyRouter.getExchange();\r\n//         dodo.transfer(address(exchange), amountA);\r\n//         receivedA = exchange.swap(amountA, address(dodo), address(tokenA), address(this));\r\n\r\n//         dodo.transfer(address(exchange), amountB);\r\n//         receivedB = exchange.swap(amountB, address(dodo), address(tokenB), address(this));\r\n\r\n//         (receivedA, receivedB) = collectProtocolCommission(receivedA, receivedB);\r\n//     }\r\n\r\n//     function collectProtocolCommission(uint256 amountA, uint256 amountB)\r\n//         private\r\n//         returns (uint256 amountAfterFeeA, uint256 amountAfterFeeB)\r\n//     {\r\n//         uint256 feePercent = StrategyRouter(strategyRouter).feePercent();\r\n//         address feeAddress = StrategyRouter(strategyRouter).feeAddress();\r\n//         uint256 ratioUint;\r\n//         uint256 feeAmount = ((amountA + amountB) * feePercent) / PERCENT_DENOMINATOR;\r\n//         {\r\n//             (uint256 r0, uint256 r1, ) = IUniswapV2Pair(address(lpToken)).getReserves();\r\n\r\n//             // equation: (a - (c*v))/(b - (c-c*v)) = z/x\r\n//             // solution for v = (a*x - b*z + c*z) / (c * (z+x))\r\n//             // a,b is current token amounts, z,x is pair reserves, c is total fee amount to take from a+b\r\n//             // v is ratio to apply to feeAmount and take fee from a and b\r\n//             // a and z should be converted to same decimals as token b (TODO for cases when decimals are different)\r\n//             int256 numerator = int256(amountA * r1 + feeAmount * r0) - int256(amountB * r0);\r\n//             int256 denominator = int256(feeAmount * (r0 + r1));\r\n//             int256 ratio = (numerator * 1e18) / denominator;\r\n//             // ratio here could be negative or greater than 1.0\r\n//             // only need to be between 0 and 1\r\n//             if (ratio < 0) ratio = 0;\r\n//             if (ratio > 1e18) ratio = 1e18;\r\n\r\n//             ratioUint = uint256(ratio);\r\n//         }\r\n\r\n//         // these two have same decimals, should adjust A to have A decimals,\r\n//         // this is TODO for cases when tokenA and tokenB has different decimals\r\n//         uint256 comissionA = (feeAmount * ratioUint) / 1e18;\r\n//         uint256 comissionB = feeAmount - comissionA;\r\n\r\n//         tokenA.transfer(feeAddress, comissionA);\r\n//         tokenB.transfer(feeAddress, comissionB);\r\n\r\n//         return (amountA - comissionA, amountB - comissionB);\r\n//     }\r\n\r\n//     function calculateSwapAmount(uint256 half, uint256 dexFee) private view returns (uint256 amountAfterFee) {\r\n//         (uint256 r0, uint256 r1, ) = IUniswapV2Pair(address(lpToken)).getReserves();\r\n//         uint256 halfWithFee = (2 * r0 * (dexFee + 1e18)) / ((r0 * (dexFee + 1e18)) / 1e18 + r1);\r\n//         uint256 amountB = (half * halfWithFee) / 1e18;\r\n//         return amountB;\r\n//     }\r\n\r\n\r\n// }",
  "sourcePath": "C:\\Users\\FVO_MMILLLER\\Desktop\\elvolution\\Testers\\contracts\\verify\\DodoStrategy.sol",
  "ast": {
    "absolutePath": "project:/contracts/verify/DodoStrategy.sol",
    "exportedSymbols": {
      "Context": [
        26161
      ]
    },
    "id": 26162,
    "license": "Unlicense",
    "nodeType": "SourceUnit",
    "nodes": [
      {
        "abstract": true,
        "baseContracts": [],
        "canonicalName": "Context",
        "contractDependencies": [],
        "contractKind": "contract",
        "fullyImplemented": true,
        "id": 26161,
        "linearizedBaseContracts": [
          26161
        ],
        "name": "Context",
        "nameLocation": "628:7:75",
        "nodeType": "ContractDefinition",
        "nodes": [
          {
            "body": {
              "id": 26150,
              "nodeType": "Block",
              "src": "705:36:75",
              "statements": [
                {
                  "expression": {
                    "expression": {
                      "id": 26147,
                      "name": "msg",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 4294967281,
                      "src": "723:3:75",
                      "typeDescriptions": {
                        "typeIdentifier": "t_magic_message",
                        "typeString": "msg"
                      }
                    },
                    "id": 26148,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "memberName": "sender",
                    "nodeType": "MemberAccess",
                    "src": "723:10:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "functionReturnParameters": 26146,
                  "id": 26149,
                  "nodeType": "Return",
                  "src": "716:17:75"
                }
              ]
            },
            "id": 26151,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "_msgSender",
            "nameLocation": "652:10:75",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 26143,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "662:2:75"
            },
            "returnParameters": {
              "id": 26146,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 26145,
                  "mutability": "mutable",
                  "name": "",
                  "nameLocation": "-1:-1:-1",
                  "nodeType": "VariableDeclaration",
                  "scope": 26151,
                  "src": "696:7:75",
                  "stateVariable": false,
                  "storageLocation": "default",
                  "typeDescriptions": {
                    "typeIdentifier": "t_address",
                    "typeString": "address"
                  },
                  "typeName": {
                    "id": 26144,
                    "name": "address",
                    "nodeType": "ElementaryTypeName",
                    "src": "696:7:75",
                    "stateMutability": "nonpayable",
                    "typeDescriptions": {
                      "typeIdentifier": "t_address",
                      "typeString": "address"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "695:9:75"
            },
            "scope": 26161,
            "src": "643:98:75",
            "stateMutability": "view",
            "virtual": true,
            "visibility": "internal"
          },
          {
            "body": {
              "id": 26159,
              "nodeType": "Block",
              "src": "816:34:75",
              "statements": [
                {
                  "expression": {
                    "expression": {
                      "id": 26156,
                      "name": "msg",
                      "nodeType": "Identifier",
                      "overloadedDeclarations": [],
                      "referencedDeclaration": 4294967281,
                      "src": "834:3:75",
                      "typeDescriptions": {
                        "typeIdentifier": "t_magic_message",
                        "typeString": "msg"
                      }
                    },
                    "id": 26157,
                    "isConstant": false,
                    "isLValue": false,
                    "isPure": false,
                    "lValueRequested": false,
                    "memberName": "data",
                    "nodeType": "MemberAccess",
                    "src": "834:8:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_calldata_ptr",
                      "typeString": "bytes calldata"
                    }
                  },
                  "functionReturnParameters": 26155,
                  "id": 26158,
                  "nodeType": "Return",
                  "src": "827:15:75"
                }
              ]
            },
            "id": 26160,
            "implemented": true,
            "kind": "function",
            "modifiers": [],
            "name": "_msgData",
            "nameLocation": "758:8:75",
            "nodeType": "FunctionDefinition",
            "parameters": {
              "id": 26152,
              "nodeType": "ParameterList",
              "parameters": [],
              "src": "766:2:75"
            },
            "returnParameters": {
              "id": 26155,
              "nodeType": "ParameterList",
              "parameters": [
                {
                  "constant": false,
                  "id": 26154,
                  "mutability": "mutable",
                  "name": "",
                  "nameLocation": "-1:-1:-1",
                  "nodeType": "VariableDeclaration",
                  "scope": 26160,
                  "src": "800:14:75",
                  "stateVariable": false,
                  "storageLocation": "calldata",
                  "typeDescriptions": {
                    "typeIdentifier": "t_bytes_calldata_ptr",
                    "typeString": "bytes"
                  },
                  "typeName": {
                    "id": 26153,
                    "name": "bytes",
                    "nodeType": "ElementaryTypeName",
                    "src": "800:5:75",
                    "typeDescriptions": {
                      "typeIdentifier": "t_bytes_storage_ptr",
                      "typeString": "bytes"
                    }
                  },
                  "visibility": "internal"
                }
              ],
              "src": "799:16:75"
            },
            "scope": 26161,
            "src": "749:101:75",
            "stateMutability": "view",
            "virtual": true,
            "visibility": "internal"
          }
        ],
        "scope": 26162,
        "src": "610:243:75",
        "usedErrors": []
      }
    ],
    "src": "610:135616:75"
  },
  "compiler": {
    "name": "solc",
    "version": "0.8.15+commit.e14f2714.Emscripten.clang"
  },
  "networks": {},
  "schemaVersion": "3.4.8",
  "updatedAt": "2022-09-08T16:23:05.263Z",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  }
}